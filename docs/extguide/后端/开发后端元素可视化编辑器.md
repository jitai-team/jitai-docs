# å¼€å‘åç«¯å…ƒç´ å¯è§†åŒ–ç¼–è¾‘å™¨

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

å½“æˆ‘ä»¬å®Œæˆäº†[æ–°å¢åç«¯Typeå…ƒç´ ](/docs/extguide/åç«¯/æ–°å¢åç«¯Typeå…ƒç´ .md)åï¼Œè™½ç„¶å¯ä»¥åˆ›å»ºå®ä¾‹å¹¶è¿è¡Œï¼Œä½†é…ç½®å‚æ•°éœ€è¦æ‰‹åŠ¨ä¿®æ”¹æ–‡ä»¶ï¼Œè¿™å¯¹ä¸ç†Ÿæ‚‰ä»£ç çš„ä¸šåŠ¡å¼€å‘è€…æ¥è¯´å¹¶ä¸å‹å¥½ã€‚

æœ¬æ–‡å°†ä»‹ç»å¦‚ä½•ä¸ºé’‰é’‰æœºå™¨äººå¼€å‘å¯è§†åŒ–é…ç½®ç¼–è¾‘å™¨ï¼Œå®ç°åœ¨JitAiå¼€å‘å·¥å…·ä¸­åƒå®˜æ–¹å…ƒç´ ä¸€æ ·çš„å›¾å½¢åŒ–é…ç½®ä½“éªŒã€‚

## æ•ˆæœé¢„è§ˆ

![ç¼–è¾‘å™¨æ•ˆæœ](./img/é’‰é’‰æœºå™¨äºº-å…ƒç´ é…ç½®ç•Œé¢.png)

## ç¼–è¾‘å™¨æ¶æ„

| å…ƒç´ å±‚æ¬¡ | fullName | ä¸»è¦èŒè´£ |
|---------|----------|----------|
| **ç¼–è¾‘å™¨å…ƒç´ ** | `imRobots.dingTalkStreamType.Editor` | typeæŒ‡å‘`editors.React`ï¼Œä¸ºé’‰é’‰æœºå™¨äººæä¾›å¯è§†åŒ–é…ç½®ç•Œé¢ |
| **ç›®æ ‡å…ƒç´ ** | `imRobots.dingTalkStreamType` | è¢«ç¼–è¾‘çš„ç›®æ ‡åç«¯Typeå…ƒç´ ï¼Œå·²åœ¨å‰é¢ç« èŠ‚å®Œæˆ |

### ç¼–è¾‘å™¨ç›®å½•ç»“æ„

```shell title="åœ¨dingTalkStreamTypeä¸‹æ–°å¢Editorå­ç›®å½•"
imRobots/
â””â”€â”€ dingTalkStreamType/              # åç«¯Typeå…ƒç´ ï¼ˆå·²å®Œæˆï¼‰
    â”œâ”€â”€ e.json                       # Typeå…ƒç´ å®šä¹‰
    â”œâ”€â”€ config.json                  # é…ç½®æ¨¡æ¿
    â”œâ”€â”€ loader.py                    # åŠ è½½å™¨å®ç°
    â”œâ”€â”€ client_manager.py           # å®¢æˆ·ç«¯ç®¡ç†
    â”œâ”€â”€ handler.py                  # æ¶ˆæ¯å¤„ç†å™¨
    â””â”€â”€ Editor/                     # ç¼–è¾‘å™¨ç›®å½•ï¼ˆæ–°å¢ï¼‰
        â”œâ”€â”€ e.json                  # ç¼–è¾‘å™¨å…ƒç´ å®šä¹‰
        â”œâ”€â”€ index.ts               # ç¼–è¾‘å™¨å…¥å£æ–‡ä»¶
        â”œâ”€â”€ Editor.tsx             # ç¼–è¾‘å™¨å®ç°æ–‡ä»¶
        â”œâ”€â”€ Editor.style.ts        # æ ·å¼æ–‡ä»¶
        â””â”€â”€ utils.ts               # å·¥å…·å‡½æ•°
```

## æ“ä½œæŒ‡å—

### åˆ›å»ºç¼–è¾‘å™¨ç›®å½•

åœ¨dingTalkStreamTypeç›®å½•ä¸‹åˆ›å»ºEditorå­ç›®å½•ï¼š

```bash
# åœ¨dingTalkStreamTypeç›®å½•ä¸‹æ‰§è¡Œ
mkdir -p Editor
```

### å®‰è£…ä¾èµ–

åœ¨é¡¹ç›®çš„`package.json`ä¸­æ·»åŠ Monacoç¼–è¾‘å™¨ä¾èµ–ï¼š

```json title="package.json"
{
  "dependencies": {
    "@monaco-editor/react": "^4.7.0"
  }
}
```

### å®ç°ç¼–è¾‘å™¨æ–‡ä»¶

<Tabs>
  <TabItem value="config" label="å…ƒç´ å®šä¹‰æ–‡ä»¶">

**åˆ›å»ºç¼–è¾‘å™¨å…ƒç´ å®šä¹‰æ–‡ä»¶** `Editor/e.json`ï¼š

:::tip ç¼–è¾‘å™¨ä¹Ÿæ˜¯å…ƒç´ 
åœ¨JitAiä¸­ï¼Œç¼–è¾‘å™¨æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªå…ƒç´ ï¼Œæ‹¥æœ‰è‡ªå·±çš„`e.json`å®šä¹‰æ–‡ä»¶ã€‚
:::

```json title="Editor/e.json"
{
  "frontBundleEntry": "./index.ts",
  "outputName": "index",
  "tag": "editor",
  "targetType": [
    "imRobots.dingTalkStreamType"
  ],
  "title": "é’‰é’‰æœºå™¨äººé…ç½®ç¼–è¾‘å™¨",
  "type": "editors.React"
}
```

**ç¼–è¾‘å™¨å…ƒç´ é…ç½®è¯´æ˜ï¼š**

<ul>
<li><code>title</code>: ç¼–è¾‘å™¨å…ƒç´ æ˜¾ç¤ºåç§°</li>
<li><code>type</code>: å›ºå®šä¸º<code>editors.React</code>ï¼Œè¡¨ç¤ºReactç¼–è¾‘å™¨å…ƒç´ </li>
<li><code>tag</code>: å›ºå®šä¸º<code>editor</code>ï¼Œè¡¨ç¤ºåç«¯å…ƒç´ ç¼–è¾‘å™¨</li>
<li><code>targetType</code>: ç›®æ ‡åç«¯å…ƒç´ çš„fullName</li>
<li><code>frontBundleEntry</code>: ç¼–è¾‘å™¨å…¥å£æ–‡ä»¶</li>
</ul>

  </TabItem>
  <TabItem value="index" label="å…¥å£æ–‡ä»¶">

**åˆ›å»ºç¼–è¾‘å™¨å…¥å£æ–‡ä»¶** `Editor/index.ts`ï¼š

```typescript title="Editor/index.ts"
export { Editor } from './Editor';
```

:::important ç¼–è¾‘å™¨å¯¼å‡ºè§„èŒƒ
ç¼–è¾‘å™¨å¿…é¡»å¯¼å‡ºåä¸º`Editor`çš„ç»„ä»¶ï¼Œè¿™æ˜¯JitAiå·¥å…·è¯†åˆ«ç¼–è¾‘å™¨çš„å›ºå®šçº¦å®šã€‚
:::

  </TabItem>
  <TabItem value="utils" label="å·¥å…·å‡½æ•°">

**åˆ›å»ºå·¥å…·å‡½æ•°** `Editor/utils.ts`ï¼š

```typescript title="Editor/utils.ts"
type TreeData = { key: string; title: string; children?: TreeData[]; };

export const file2Tree = (files: Record<string, string>) => {
    const result: TreeData[] = [];
    Object.keys(files).forEach((path) => {
        if (path.includes('/')) {
            addToTree(result, path);
        } else {
            result.push({ key: path, title: path });
        }
    });
    return result;
};

const addToTree = (tree: TreeData[], path: string, level = 0): void => {
    const parts = path.split('/');
    if (level >= parts.length) return;
    const key = parts.slice(0, level + 1).join('/');
    const name = parts[level];
    const isFile = level === parts.length - 1;
    let node = tree.find(n => n.key === key);
    if (!node) {
        node = { key, title: name };
        if (!isFile) node.children = [];
        tree.push(node);
    }
    if (!isFile) addToTree(node.children!, path, level + 1);
};

const iconMap: Record<string, string> = {
    json: 'ğŸ“„', md: 'ğŸ“', ts: 'ğŸ”·', tsx: 'ğŸ”·', js: 'ğŸŸ¨', jsx: 'ğŸŸ¨', css: 'ğŸ¨', scss: 'ğŸ¨', html: 'ğŸŒ'
};

const langMap: Record<string, string> = {
    json: 'json', md: 'markdown', ts: 'typescript', tsx: 'typescript',
    js: 'javascript', jsx: 'javascript', css: 'css', scss: 'scss', html: 'html'
};

export const getFileIcon = (fileName: string): string => {
    const ext = fileName.split('.').pop() || '';
    return iconMap[ext] || 'ğŸ“„';
};

export const getLanguageByFileName = (fileName: string): string => {
    const ext = fileName.split('.').pop() || '';
    return langMap[ext] || 'plaintext';
};
```

  </TabItem>
  <TabItem value="styles" label="æ ·å¼æ–‡ä»¶">

**åˆ›å»ºæ ·å¼æ–‡ä»¶** `Editor/Editor.style.ts`ï¼š

```typescript title="Editor/Editor.style.ts"
import type { GlobalToken } from 'antd';
import { css } from '@emotion/react';

export const editorStyle = (token: GlobalToken) => css`
    width: 100%; height: 100%; text-align: left;

    .ant-tree-treenode { border-radius: 4px; height: 40px; &:hover { background-color: ${token.colorPrimaryBg}; } }
    .code-editor-container { display: flex; width: 100%; height: 100%; background-color: #fff; }
    .file-list-container { width: 280px; flex-shrink: 0; border-right: 1px solid rgba(189, 198, 217, 0.24); display: flex; flex-direction: column; padding: 10px; background-color: ${token.colorBgContainer}; }
    .file-list-title { font-size: 14px; font-weight: 500; margin-bottom: 10px; color: ${token.colorTextSecondary}; }
    .gui-container { display: flex; justify-content: center; align-items: center; height: 100%; background-color: ${token.colorBgContainer}; }
    .gui-form { width: 100%; max-width: 400px; margin: 0 auto; }
`;

export const titleContentStyle = (token: GlobalToken) => css`
    display: flex; align-items: center; justify-content: space-between; width: 100%;
    .title-left { font-size: 14px; font-weight: 500; color: ${token.colorText}; }
    .title-right { display: flex; align-items: center; gap: 8px; 
        .ant-segmented { background: ${token.colorFill}; border-radius: 32px;
            .ant-segmented-item-selected { background-color: ${token.colorPrimary}; border-radius: 28px; color: ${token.colorBgBase}; }
        }
    }
    .file-path { color: ${token.colorTextSecondary}; font-family: Monaco, Consolas, monospace; font-size: 13px; }
`;
```

  </TabItem>
  <TabItem value="editor" label="ç¼–è¾‘å™¨å®ç°">

**åˆ›å»ºä¸»ç¼–è¾‘å™¨æ–‡ä»¶** `Editor/Editor.tsx`ï¼š

```tsx title="Editor/Editor.tsx"
import type React from 'react';
import type { ForwardedRef } from 'react';
import { getRuntimeApp } from 'jit';
import { forwardRef, useCallback, useEffect, useImperativeHandle, useState } from 'react';
import { Button, Content, Tree, Icon } from 'jit-ui';
import { Form, Input, message, Badge, theme, Segmented } from 'antd';
import MonacoEditor, { loader } from '@monaco-editor/react';
import { editorStyle, titleContentStyle } from './Editor.style';
import { file2Tree, getFileIcon, getLanguageByFileName } from './utils';

loader.config({ paths: { vs: `${window.PUBLIC_RESOURCE}/wanyun/package/monaco-editor@0.41.0/min/vs` } });

interface EditorProps { fullName: string; enablePageCloseTip: (flag: boolean) => void; }
interface DingTalkConfig { clientId?: string; clientSecret?: string; agent?: string; }
export enum TitleOptSwitchEnum { CONFIG = 'config', CODE = 'code' }

const TitleOpt: React.FC<{ value: TitleOptSwitchEnum; onChange: (v: TitleOptSwitchEnum) => void; }> = ({ value, onChange }) => (
    <Segmented value={value} onChange={onChange} size="small" options={[
        { value: TitleOptSwitchEnum.CONFIG, icon: <Icon name="peizhi" /> },
        { value: TitleOptSwitchEnum.CODE, icon: <Icon name="IDEyuanma" /> }
    ]} />
);

export const MyEditor = forwardRef((props: EditorProps, ref: ForwardedRef<any>) => {
    const { fullName, enablePageCloseTip } = props;
    const { token } = theme.useToken();
    const [config, setConfig] = useState<DingTalkConfig>({});
    const [elementFiles, setElementFiles] = useState<Record<string, string>>({});
    const [activeFile, setActiveFile] = useState('config.json');
    const [tabName, setTabName] = useState<TitleOptSwitchEnum>(TitleOptSwitchEnum.CONFIG);
    const [loading, setLoading] = useState(false);
    const [changed, setChanged] = useState(false);
    const [expandedKeys, setExpandedKeys] = useState<string[]>([]);

    const loadFiles = useCallback(async () => {
        try {
            const app = getRuntimeApp();
            const resources = await app.getElementResource(fullName);
            const files: Record<string, string> = {};
            Object.keys(resources).forEach(fileName => { files[fileName] = resources[fileName] || ''; });
            if (!files['config.json']) files['config.json'] = JSON.stringify({}, null, 2);
            setElementFiles(files);
            try { setConfig(JSON.parse(files['config.json'] || '{}')); } catch { message.error('é…ç½®æ–‡ä»¶æ ¼å¼é”™è¯¯'); setConfig({}); }
            const fileKeys = Object.keys(files);
            setActiveFile(fileKeys.includes('config.json') ? 'config.json' : fileKeys[0]);
        } catch (error) { message.error(`åŠ è½½å¤±è´¥: ${(error as Error).message}`); }
    }, [fullName]);

    const saveFiles = useCallback(async () => {
        setLoading(true);
        try {
            const app = getRuntimeApp();
            const filesToSave = { ...elementFiles };
            if (tabName === TitleOptSwitchEnum.CONFIG) {
                if (!config.clientId || !config.clientSecret || !config.agent) { message.error('è¯·å¡«å†™å®Œæ•´çš„é…ç½®ä¿¡æ¯'); return false; }
                filesToSave['config.json'] = JSON.stringify(config, null, 2);
            } else if (activeFile === 'config.json') {
                try { setConfig(JSON.parse(elementFiles[activeFile])); } catch { message.error('config.jsonæ ¼å¼é”™è¯¯'); return false; }
            }
            await app.saveElementResource(fullName, filesToSave);
            setElementFiles(filesToSave); message.success('ä¿å­˜æˆåŠŸ'); enablePageCloseTip(false); setChanged(false); return true;
        } catch (error) { message.error('ä¿å­˜å¤±è´¥'); return false; } finally { setLoading(false); }
    }, [fullName, config, elementFiles, activeFile, tabName, enablePageCloseTip]);

    const markChanged = () => { setChanged(true); enablePageCloseTip(true); };
    const updateConfig = (field: keyof DingTalkConfig, value: string) => {
        const newConfig = { ...config, [field]: value }; setConfig(newConfig);
        elementFiles['config.json'] = JSON.stringify(newConfig, null, 2); setElementFiles({ ...elementFiles }); markChanged();
    };
    const updateFileContent = (value: string) => { elementFiles[activeFile] = value; setElementFiles({ ...elementFiles }); markChanged(); };

    useImperativeHandle(ref, () => ({ save: saveFiles }));
    useEffect(() => { loadFiles(); }, [loadFiles]);

    return (
        <Content title={null} titleContent={
            <div css={titleContentStyle(token)}>
                <div className="title-left">{tabName === TitleOptSwitchEnum.CONFIG ? 'å…ƒç´ é…ç½®' : <span className="file-path">{fullName.replace('.', '/')}/{activeFile}</span>}</div>
                <div className="title-right"><TitleOpt value={tabName} onChange={setTabName} /><Badge dot={changed}><Button type="primary" size="small" loading={loading} onClick={saveFiles}>ä¿å­˜</Button></Badge></div>
            </div>
        }>
            <div css={editorStyle(token)}>
                {tabName === TitleOptSwitchEnum.CONFIG ? (
                    <div className="gui-container"><Form layout="vertical" className="gui-form">
                        <Form.Item label="Client ID" required><Input value={config.clientId || ''} onChange={(e) => updateConfig('clientId', e.target.value)} placeholder="è¯·è¾“å…¥Client ID" /></Form.Item>
                        <Form.Item label="Client Secret" required><Input.Password value={config.clientSecret || ''} onChange={(e) => updateConfig('clientSecret', e.target.value)} placeholder="è¯·è¾“å…¥Client Secret" /></Form.Item>
                        <Form.Item label="AiAgent Fullname" required><Input value={config.agent || ''} onChange={(e) => updateConfig('agent', e.target.value)} placeholder="è¯·è¾“å…¥AiAgent Fullname" /></Form.Item>
                    </Form></div>
                ) : (
                    <div className="code-editor-container">
                        <div className="file-list-container"><div className="file-list-title">æ–‡ä»¶åˆ—è¡¨</div>
                            <Tree treeData={file2Tree(elementFiles)} expandedKeys={expandedKeys} onExpand={setExpandedKeys}
                                onSelect={(keys) => keys[0] && setActiveFile(keys[0])} selectedKeys={[activeFile]} showIcon
                                icon={({ data, expanded }: any) => data.children ? (expanded ? 'ğŸ“‚' : 'ğŸ“') : getFileIcon(data.title)}
                                titleRender={(node: any) => <span style={{ fontSize: '14px' }}>{node.title}</span>} />
                        </div>
                        <div style={{ flex: 1, position: 'relative', width: '100%' }}>
                            <MonacoEditor height="100%" language={getLanguageByFileName(activeFile)} value={elementFiles[activeFile] || ''} theme="vs-dark"
                                onChange={(value) => updateFileContent(value || '')} options={{ automaticLayout: true, wordWrap: 'on', minimap: { enabled: false }, fontSize: 14, tabSize: 2, lineNumbers: 'on' }} />
                        </div>
                    </div>
                )}
            </div>
        </Content>
    );
});

export const Editor = MyEditor;
```

  </TabItem>
</Tabs>

## å®šåˆ¶æ‚¨çš„ç¼–è¾‘å™¨

### ä¿®æ”¹å…ƒç´ é…ç½®

åœ¨ `Editor/e.json` ä¸­ï¼Œå°† `targetType` æ”¹ä¸ºæ‚¨çš„åç«¯å…ƒç´ ï¼š

```json
{
  "targetType": ["yourOrg.YourBackendType"],
  "title": "æ‚¨çš„å…ƒç´ ç¼–è¾‘å™¨"
}
```

### å®šä¹‰é…ç½®ç»“æ„

åœ¨ `Editor.tsx` ä¸­ï¼Œä¿®æ”¹é…ç½®æ¥å£å’Œè¡¨å•ï¼š

```tsx
// ä¿®æ”¹é…ç½®æ¥å£
interface YourConfig {
    apiKey?: string;
    endpoint?: string;
    timeout?: number;
}

// ä¿®æ”¹çŠ¶æ€ç±»å‹
const [config, setConfig] = useState<YourConfig>({});

// ä¿®æ”¹è¡¨å•å­—æ®µ
<Form.Item label="API Key" required>
    <Input
        value={config.apiKey || ''}
        onChange={(e) => updateConfig('apiKey', e.target.value)}
        placeholder="è¯·è¾“å…¥API Key"
    />
</Form.Item>

// ä¿®æ”¹éªŒè¯é€»è¾‘
if (!config.apiKey || !config.endpoint) {
    message.error('è¯·å¡«å†™å®Œæ•´é…ç½®');
    return false;
}
```

## æµ‹è¯•

### ä½¿ç¼–è¾‘å™¨ç”Ÿæ•ˆ
1. **æ¸…ç†ç¼“å­˜**ï¼šåˆ é™¤åº”ç”¨ç›®å½•ä¸­çš„`dist`ç›®å½•  
2. **é‡å¯æœåŠ¡**ï¼šé‡å¯æ¡Œé¢ç«¯
3. **è§¦å‘æ‰“åŒ…**ï¼šè®¿é—®åº”ç”¨é¡µé¢ï¼Œç³»ç»Ÿè‡ªåŠ¨é‡æ–°æ‰“åŒ…

### éªŒè¯ç¼–è¾‘å™¨åŠŸèƒ½
1. **åˆ›å»ºå…ƒç´ å®ä¾‹**ï¼šåœ¨JitAiå¼€å‘å·¥å…·ä¸­åˆ›å»ºé’‰é’‰æœºå™¨äººå…ƒç´ å®ä¾‹
2. **æ‰“å¼€ç¼–è¾‘å™¨**ï¼šç‚¹å‡»å…ƒç´ å®ä¾‹è¿›å…¥ç¼–è¾‘å™¨
3. **åˆ‡æ¢æ¨¡å¼**ï¼šç‚¹å‡»é…ç½®/ä»£ç å›¾æ ‡ï¼ŒéªŒè¯æ¨¡å¼åˆ‡æ¢
4. **ä¿®æ”¹é…ç½®**ï¼šå°è¯•åœ¨GUIæ¨¡å¼ä¿®æ”¹é…ç½®ï¼Œè§‚å¯Ÿä»£ç æ¨¡å¼æ˜¯å¦åŒæ­¥
5. **ä¿å­˜éªŒè¯**ï¼šä¿å­˜åé‡æ–°æ‰“å¼€ï¼Œç¡®è®¤é…ç½®å·²æŒä¹…åŒ–

### å¸¸è§é—®é¢˜æ’æŸ¥
- **ç¼–è¾‘å™¨ä¸æ˜¾ç¤º**ï¼šæ£€æŸ¥`targetType`ä¸­çš„åç«¯å…ƒç´ åç§°æ˜¯å¦æ­£ç¡®
- **Monacoç¼–è¾‘å™¨ä¸æ˜¾ç¤º**ï¼šæ£€æŸ¥`@monaco-editor/react`ä¾èµ–æ˜¯å¦å®‰è£…
- **ä¿å­˜å¤±è´¥**ï¼šæŸ¥çœ‹æµè§ˆå™¨æ§åˆ¶å°ï¼Œæ£€æŸ¥APIè°ƒç”¨æ˜¯å¦æ­£å¸¸

## æ€»ç»“

ä¸ºåç«¯å…ƒç´ å¼€å‘å¯è§†åŒ–ç¼–è¾‘å™¨çš„**æ ¸å¿ƒæ­¥éª¤**ï¼š

1. **åˆ›å»ºEditorç›®å½•** + é…ç½®ç¼–è¾‘å™¨å…ƒç´ å®šä¹‰æ–‡ä»¶`e.json`ï¼ˆ`type: "editors.React"`ï¼‰
2. **å®ç°Editorç»„ä»¶**ï¼šæ”¯æŒGUI/ä»£ç åŒæ¨¡å¼ + æ–‡ä»¶ç®¡ç† + åŒå‘åŒæ­¥
3. **å®šåˆ¶é…ç½®ç»“æ„**ï¼šæ ¹æ®åç«¯å…ƒç´ éœ€æ±‚è°ƒæ•´é…ç½®æ¥å£å’Œè¡¨å•
4. **æµ‹è¯•éªŒè¯**ï¼šç¡®ä¿ç¼–è¾‘å™¨åœ¨JitAiä¸­æ­£å¸¸å·¥ä½œ

**å…³é”®è¦ç‚¹**ï¼š
- å¯¼å‡ºå`Editor`ä¸å¯æ›´æ”¹
- `targetType`å¿…é¡»æ­£ç¡®æŒ‡å‘åç«¯å…ƒç´ 
- ä½¿ç”¨`getElementResource`å’Œ`saveElementResource` APIè¿›è¡Œæ–‡ä»¶ç®¡ç†
- GUIæ¨¡å¼ä¸ä»£ç æ¨¡å¼éœ€è¦ä¿æŒæ•°æ®åŒæ­¥