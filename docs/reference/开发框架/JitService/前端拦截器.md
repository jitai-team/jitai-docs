# 前端拦截器

基于前端网络请求拦截机制（如 Axios 拦截器），在请求发出前与响应返回后统一处理客户端逻辑，例如添加请求头、参数签名、响应解包、错误处理与令牌刷新等。

拦截器元素分层结构为 Meta（interceptors.Meta） → Type（interceptors.Http） → 实例，仅支持全代码方式创建。

## 快速开始

### 创建实例元素

#### 目录结构

```text title="推荐前端拦截器元素目录结构"
interceptors/
└── MyInterceptor/
    ├── index.ts
    ├── e.json
```

#### e.json 文件

```json title="前端拦截器 e.json 示例"
{
  "title": "自定义拦截器",
  "type": "interceptors.Http",
  "frontBundleEntry": "./index.ts",
  "icon": "lanjieqi1",
  "sort": 100
}
```

#### 编写代码
需要导出reqInterceptor和respInterceptor两个方法。

```typescript title="index.ts（模板）"
import type { InternalAxiosRequestConfig } from 'axios';
import type { HttpResponse } from 'jit';

// 请求拦截：在这里读取/设置请求头、参数等；最后返回 request
export const reqInterceptor = (request: InternalAxiosRequestConfig) => {
  // 可自定义：读取已有头
  // const auth = request.headers['Authorization'];

  // 可自定义：设置自定义头或修改请求
  // request.headers['X-Custom-Header'] = 'value';
  // request.params = { ...(request.params || {}), traceId: '...' };
  // request.data = request.data; // 也可在此序列化/变换

  return request;
};

// 响应拦截：在这里统一处理响应数据、错误码、令牌刷新等；最后返回 response
export const respInterceptor = (response: HttpResponse & Record<string, any>) => {
  // 可自定义：统一解包或数据转换
  // const { data } = response;
  // if (data && data.payload) {
  //   response.data = data.payload;
  // }

  // 可自定义：通用状态处理/错误抛出
  // if (data && data.code !== 0) {
  //   // throw 或标准化错误
  // }

  return response;
};
```

## 方法

### reqInterceptor

请求发出前触发。可在此读取与设置请求头、查询参数与请求体，进行序列化、埋点、签名等处理。函数需返回修改后的 `request` 对象。

### respInterceptor

响应返回后触发。可在此统一解包、数据转换、错误码处理、令牌刷新等。函数需返回（或抛出）处理过的 `response` 对象。

## 高级特性

### 执行顺序

通过 `e.json` 中的 `sort` 字段控制拦截器执行顺序。

```json title="设置执行顺序"
{
  "title": "高优先级拦截器",
  "type": "interceptors.Http",
  "sort": 10
}
```

同时存在多个拦截器？
- 在请求发出前，按照 `sort` 升序执行 `reqInterceptor`
- 在响应返回后，按照 `sort` 降序执行 `respInterceptor`

### 平台内置拦截器

请求加签 `interceptors.encryptor`

JitNode校验信息获取 `interceptors.JitNodeValid`

接口异常信息获取 `interceptors.exception`