---
sidebar_position: 4
---

# é›†æˆæ™ºèƒ½å®¢æœåˆ°é’‰é’‰æœºå™¨äºº

:::info 
æœ¬æ–‡é€‚åˆå¯¹ææ€æœ‰ä¸€å®šäº†è§£çš„å¼€å‘è€…ï¼Œé€šè¿‡å¯¹æœ¬æ–‡çš„å­¦ä¹ ï¼Œä½ å°†è·å¾—ä»¥ä¸‹æ”¶è·ï¼š
1. å¯¹ææ€[å…ƒç´ æœºåˆ¶](../01æ¦‚è¿°/03å…ƒç´ è§„èŒƒ)æœ‰ä¸€å®šç¨‹åº¦çš„ç†è§£ï¼Œæœ‰èƒ½åŠ›éµå¾ªå…ƒç´ æœºåˆ¶è‡ªå®šä¹‰å…ƒç´ æ—ç±»ã€‚
2. å°†æ™ºèƒ½å®¢æœæ™ºèƒ½ä½“é›†æˆåˆ°é’‰é’‰æœºå™¨äººã€‚å»ºè®®å…ˆå®Œæˆ[ã€Š5åˆ†é’Ÿå¼€å‘ä¸€ä¸ªAIåº”ç”¨ï¼ˆæ™ºèƒ½å®¢æœï¼‰ã€‹](../00å¿«é€Ÿä¸Šæ‰‹/03-5åˆ†é’Ÿå¼€å‘ä¸€ä¸ªAIåº”ç”¨ï¼ˆæ™ºèƒ½å®¢æœï¼‰)çš„å­¦ä¹ ã€‚

:::

## æ•ˆæœé¢„è§ˆ

![æ™ºèƒ½ä½“é›†æˆåˆ°é’‰é’‰æœºå™¨äººä¸­](./img/jitairobot/æœ€ç»ˆæ•ˆæœ_DingTalk.png)

---

## å‰ç½®å‡†å¤‡

### é’‰é’‰è´¦å·ä¸ä¼ä¸šåˆ›å»º

1. æ³¨å†Œå¹¶ç™»å½•é’‰é’‰è´¦å·ã€‚
2. åˆ›å»ºå±äºè‡ªå·±çš„ä¼ä¸šã€‚

### é’‰é’‰å¼€å‘å¹³å°åº”ç”¨åˆ›å»º

1. ç™»å½•[é’‰é’‰å¼€å‘è€…å¹³å°](https://open-dev.dingtalk.com)ã€‚
2. è¿›å…¥[åº”ç”¨å¼€å‘](https://open-dev.dingtalk.com/fe/app?hash=%23%2Fcorp%2Fapp#/corp/app) â†’ `ä¼ä¸šå†…éƒ¨åº”ç”¨` â†’ `é’‰é’‰åº”ç”¨`ã€‚
3. ç‚¹å‡»`åˆ›å»ºåº”ç”¨`ï¼Œè®¾ç½®åº”ç”¨åç§°ã€åº”ç”¨æè¿°ï¼Œåˆ›å»ºå®Œæˆåè¿›å…¥åº”ç”¨è¯¦æƒ…é¡µã€‚
4. è¿›å…¥`åº”ç”¨èƒ½åŠ›` â†’ `æ·»åŠ åº”ç”¨èƒ½åŠ›`ï¼Œæ‰¾åˆ°`æœºå™¨äºº`å¹¶æ·»åŠ ã€‚
5. æœºå™¨äººé…ç½®ä¸­çš„æ¶ˆæ¯æ¥æ”¶æ¨¡å¼é€‰æ‹©`Streamæ¨¡å¼`ã€‚
6. å‘å¸ƒåº”ç”¨ã€‚
7. åˆ›å»ºä¸€ä¸ªä¼ä¸šå†…éƒ¨ç¾¤ï¼Œå¹¶æ·»åŠ åˆšæ‰åˆ›å»ºçš„æœºå™¨äººã€‚
8. è¿›å…¥`åŸºç¡€ä¿¡æ¯` â†’ `å‡­è¯ä¸åŸºç¡€ä¿¡æ¯` â†’ `åº”ç”¨å‡­è¯`ã€‚ä½ å¯ä»¥çœ‹åˆ°`Client ID`å’Œ`Client Secret`ï¼Œè¿™ä¸¤ä¸ªå‚æ•°å°†è¢«è®¾è®¡ä¸ºTypeå…ƒç´ çš„å¯é…ç½®å‚æ•°ã€‚

---

## å…ƒç´ æ—ç±»è®¾è®¡
ææ€[å¼€å‘æ¡†æ¶](../03å¼€å‘æŒ‡å—/02å¼€å‘æ¡†æ¶/01æ¦‚è¿°)ä¸ºå¼€å‘è€…æä¾›å¤§é‡å¼€ç®±å³ç”¨çš„å…ƒç´ æ—ç±»ï¼Œå¹¶æä¾›äº†å¯¹åº”çš„å¯è§†åŒ–é…ç½®ç•Œé¢ã€‚å½“å·²æœ‰å…ƒç´ æ—ç±»æ— æ³•æ»¡è¶³éœ€æ±‚æ—¶ï¼Œå¼€å‘è€…å¯ä»¥éµå¾ª[å…ƒç´ æœºåˆ¶](../01æ¦‚è¿°/03å…ƒç´ è§„èŒƒ)ï¼Œå®šä¹‰è‡ªå·±çš„å…ƒç´ æ—ç±»ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†å®šä¹‰ä¸€ä¸ªå…ƒç´ æ—ç±»ï¼Œå®ç°å°†æ™ºèƒ½å®¢æœé›†æˆåˆ°é’‰é’‰æœºå™¨äººçš„ä¸šåŠ¡éœ€æ±‚ã€‚

### Metaå…ƒç´ 
fullNameï¼š`imRobots.meta`

æ‰€æœ‰ä¸ä¸‰æ–¹IMæœºå™¨äººå¯¹æ¥çš„Typeå…ƒç´ ï¼Œå…¶typeå€¼éƒ½æŒ‡å‘`imRobots.meta`ã€‚
Metaå…ƒç´ è¿˜è´Ÿè´£å¯¹Typeå…ƒç´ çš„åŠ è½½ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥ä¸åœ¨Metaå…ƒç´ ä¸­å®ç°åŠ è½½é€»è¾‘ï¼Œå¹³å°ä¼šè‡ªåŠ¨ä½¿ç”¨JitNodeå†…ç½®çš„é»˜è®¤åŠ è½½å™¨ã€‚

### Typeå…ƒç´ 
fullNameï¼š`imRobots.dingTalkStreamType`

é›†æˆé’‰é’‰æœºå™¨äººSDKï¼Œå°è£…æ¶ˆæ¯æ”¶å‘ã€å¤„ç†ç­‰æŠ€æœ¯å®ç°ï¼Œå°†å¯é…ç½®çš„å‚æ•°å¼€æ”¾å‡ºå»ï¼ˆ`clientId`å’Œ`clientSecret`ï¼‰ã€‚
ä½œä¸ºTypeå…ƒç´ ï¼Œè¿˜éœ€è¦å®ç°å¯¹å®ä¾‹å…ƒç´ çš„åŠ è½½é€»è¾‘ã€‚

### å®ä¾‹å…ƒç´ 
fullNameï¼š`imRobots.dingTalkDemo`

åœ¨é…ç½®æ–‡ä»¶ä¸­é…ç½®Typeå…ƒç´ è¦æ±‚çš„å‚æ•°ï¼š`clientId`å’Œ`clientSecret`ã€‚

---

### å…ƒç´ ç›®å½•ç»“æ„

```shell title="imRobotså…ƒç´ æ—ç±»åœ¨Appä¸­çš„å­ç›®å½•ç»“æ„"
â”œâ”€â”€ imRobots/
â”‚   â”œâ”€â”€ meta/
â”‚   â”‚   â”œâ”€â”€ e.json
â”‚   â”‚   â””â”€â”€ __init__.py
â”‚   â”œâ”€â”€ dingTalkStreamType/
â”‚   â”‚   â”œâ”€â”€ e.json
â”‚   â”‚   â””â”€â”€ loader.py
â”‚   â”‚   â””â”€â”€ handler.py
â”‚   â”‚   â””â”€â”€ __init__.py
â”‚   â””â”€â”€ dingTalkDemo/
â”‚       â”œâ”€â”€ e.json
â”‚       â””â”€â”€ config.json
â”‚       â””â”€â”€ __init__.py
â”œâ”€â”€ requirements.txt
â””â”€â”€ ...

```

## å…ƒç´ æ—ç±»å®ç°
:::tip å¯¼åŒ…
æœ¬ç¤ºä¾‹éœ€è¦ä½¿ç”¨é’‰é’‰å®˜æ–¹æä¾›çš„[dingtalk_stream](https://pypi.org/project/dingtalk-stream/)åŒ…ï¼Œè¯·åœ¨Appæ ¹ç›®å½•ä¸‹çš„`requirements.txt`ä¸­æ·»åŠ `dingtalk-stream`ä¾èµ–ã€‚
```text title="requirements.txt"
dingtalk-stream==0.24.2
```
:::

### imRobots.meta Metaå…ƒç´ 

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
  <TabItem value="ejson" label="meta/e.json">

```json title="e.json"
{
  "backendBundleEntry": ".",
  "type": "",
  "title": "IMæœºå™¨äºº",
  "description": "æ‰€æœ‰å’Œä¸‰æ–¹IMæœºå™¨äººå¯¹æ¥ç›¸å…³çš„Typeå…ƒç´ ï¼Œéƒ½å½’å±äºIMæœºå™¨äººæ—ç±»"
}
```

  </TabItem>
  <TabItem value="initpy" label="meta/__init__.py">

```python title="__init__.py"
# ...
```

  </TabItem>
</Tabs>

### imRobots.dingTalkStreamType Typeå…ƒç´ 

<Tabs>
  <TabItem value="ejson" label="dingTalkStreamType/e.json">

```json title="e.json"
{
  "backendBundleEntry": ".",
  "type": "imRobots.meta",
  "title": "é’‰é’‰æœºå™¨äºº",
  "description": "å°è£…é’‰é’‰æœºå™¨äººå¯¹æ¥çš„ç»†èŠ‚ï¼ŒåŒ…æ‹¬æ¶ˆæ¯å‘é€ã€æ¥æ”¶ã€å¤„ç†ç­‰ï¼Œå°†é…ç½®å‚æ•°å¼€æ”¾"
}
```
  </TabItem>
  <TabItem value="handlerpy" label="dingTalkStreamType/handler.py">

```python title="handler.py"
from dingtalk_stream import AckMessage
import dingtalk_stream
from jit.commons.utils.logger import log as logger
import json
import time

class TextHandler(dingtalk_stream.ChatbotHandler):
    def __init__(self,element):
        super(dingtalk_stream.ChatbotHandler, self).__init__()
        self.logger = logger
        self.element=element

    def _create_initial_card(self, question: str) -> dict:
        """åˆ›å»ºåˆå§‹æ€è€ƒä¸­çš„å¡ç‰‡"""
        return {
            "config": {
                "autoLayout": True,
                "enableForward": True
            },
            "header": {
                "title": {
                    "type": "text",
                    "text": question
                }
            },
            "contents": [
                {
                    "type": "markdown",
                    "text": "[æ€è€ƒ]æ­£åœ¨åˆ†ææ‚¨çš„é—®é¢˜ï¼Œè¯·ç¨å€™...",
                    "id": f"thinking_{int(time.time() * 1000)}"
                }
            ]
        }

    def _create_streaming_card(self, content: str, question: str) -> dict:
        """åˆ›å»ºæµå¼æ›´æ–°æ—¶çš„å¡ç‰‡"""
        current_time = int(time.time() * 1000)
        
        return {
            "config": {
                "autoLayout": True,
                "enableForward": True
            },
            "header": {
                "title": {
                    "type": "text",
                    "text": question
                }
            },
            "contents": [
                {
                    "type": "markdown",
                    "text": content,
                    "id": f"answer_{current_time}"
                }
            ]
        }

    def _create_final_card(self, response: str, incoming_message: dingtalk_stream.ChatbotMessage, text: str) -> dict:
        """åˆ›å»ºæœ€ç»ˆå¸¦æŒ‰é’®çš„å¡ç‰‡"""
        return {
            "config": {
                "autoLayout": True,
                "enableForward": True
            },
            "header": {
                "title": {
                    "type": "text",
                    "text": text
                }
            },
            "contents": [
                {
                    "type": "markdown",
                    "text": response,
                    "id": f"answer_{int(time.time() * 1000)}"
                },
                {
                    "type": "divider",
                    "id": f"divider_{int(time.time() * 1000)}"
                },
                {
                    "type": "action",
                    "actions": [
                        {
                            "type": "button",
                            "label": {
                                "type": "text",
                                "text": "ğŸ˜„ éå¸¸æœ‰å¸®åŠ©",
                                "id": f"text_helpful_{int(time.time() * 1000)}"
                            },
                            "actionType": "request",
                            "status": "normal",
                            "size": "small",
                            "id": f"button_helpful_{int(time.time() * 1000)}",
                            "value": json.dumps({
                                "action": "feedback",
                                "type": "helpful",
                                "message_id": incoming_message.message_id,
                                "original_text": text,
                                "response": response
                            })
                        },
                        {
                            "type": "button",
                            "label": {
                                "type": "text",
                                "text": "ğŸ˜Š æœ‰å¸®åŠ©",
                                "id": f"text_helpful_{int(time.time() * 1000)}"
                            },
                            "actionType": "request",
                            "status": "normal",
                            "size": "small",
                            "id": f"button_helpful_{int(time.time() * 1000)}",
                            "value": json.dumps({
                                "action": "feedback",
                                "type": "helpful",
                                "message_id": incoming_message.message_id,
                                "original_text": text,
                                "response": response
                            })
                        },
                        {
                            "type": "button",
                            "label": {
                                "type": "text",
                                "text": "ğŸ™‚ å¸®åŠ©ä¸å¤§",
                                "id": f"text_unhelpful_{int(time.time() * 1000)}"
                            },
                            "actionType": "request",
                            "status": "normal",
                            "size": "small",
                            "id": f"button_unhelpful_{int(time.time() * 1000)}",
                            "value": json.dumps({
                                "action": "feedback",
                                "type": "unhelpful",
                                "message_id": incoming_message.message_id,
                                "original_text": text,
                                "response": response
                            })
                        },
                        {
                            "type": "button",
                            "label": {
                                "type": "text",
                                "text": "ğŸ˜… æ²¡å¸®åŠ©",
                                "id": f"text_unhelpful_{int(time.time() * 1000)}"
                            },
                            "actionType": "request",
                            "status": "normal",
                            "size": "small",
                            "id": f"button_unhelpful_{int(time.time() * 1000)}",
                            "value": json.dumps({
                                "action": "feedback",
                                "type": "unhelpful",
                                "message_id": incoming_message.message_id,
                                "original_text": text,
                                "response": response
                            })
                        }
                    ],
                    "id": f"action_{int(time.time() * 1000)}"
                }
            ]
        }

    async def process(self, callback: dingtalk_stream.CallbackMessage):
        """
        å¤„ç†é’‰é’‰æ¶ˆæ¯
        """
        incoming_message = dingtalk_stream.ChatbotMessage.from_dict(callback.data)        
        senderStuffId = incoming_message.sender_staff_id
        text = incoming_message.text.content.strip()
        # å‘é€åˆå§‹å¡ç‰‡
        initial_card_data = self._create_initial_card(text)
        card_biz_id = self.reply_card(
            card_data=initial_card_data,
            incoming_message=incoming_message,
            at_sender=True
        )
        # æµå¼å›è°ƒ
        def create_stream_callback(card_biz_id: str, question: str) -> callable:
            full_response = []
            update_count = 0
            last_update_time = time.time()
            pending_updates = 0
            MAX_UPDATES = 20
            def stream_callback(chunk):
                nonlocal update_count, last_update_time, pending_updates, full_response
                if chunk:
                    content = chunk.get("data",{}).get("content",None)
                    if content:
                        full_response.append(content)
                        pending_updates += 1
                        current_time = time.time()
                        
                        # æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°å¡ç‰‡
                        should_update = (
                            # æ›´æ–°æ¬¡æ•°é™åˆ¶
                            update_count < MAX_UPDATES - 1 and  # é¢„ç•™æœ€åä¸€æ¬¡æ›´æ–°
                            # æ—¶é—´é—´éš”æˆ–æ¶ˆæ¯æ•°é‡æ¡ä»¶
                            (current_time - last_update_time >= 2 or pending_updates >= 5)
                        )
                        
                        if should_update:
                            updated_card_data = self._create_streaming_card("".join(full_response), question)
                            self.update_card(card_biz_id, updated_card_data)
                            update_count += 1
                            last_update_time = current_time
                            pending_updates = 0
            return stream_callback

        response = ""
        with self.element.env.getReqContext(self.element.appId):
            CorpMember = app.getElement("corps.models.CorpMember")
            app.currentUser = CorpMember()
            agent = app.getElement("aiagents.ragTest")
            response = agent.run(
                params={"input_data": text},
                chatId=senderStuffId,
                stream_callback=create_stream_callback(card_biz_id, text)
            )

        # æ›´æ–°æœ€ç»ˆå¡ç‰‡
        final_card_data = self._create_final_card(response, incoming_message, text)
        self.update_card(card_biz_id, final_card_data)
        return AckMessage.STATUS_OK, 'OK'

        """
        å¤„ç†æŒ‰é’®å›è°ƒæ¶ˆæ¯
        """
        try:
            # è§£ææŒ‰é’®å›è°ƒæ•°æ®
            try:
                callback_data = json.loads(incoming_message.text.content)
            except json.JSONDecodeError:
                self.logger.error("Invalid JSON in button callback")
                return AckMessage.STATUS_ERROR, "Invalid callback data"

            # éªŒè¯å¿…è¦å­—æ®µ
            required_fields = ['action', 'message_id']
            if not all(field in callback_data for field in required_fields):
                self.logger.error(f"Missing required fields in callback data: {callback_data}")
                return AckMessage.STATUS_ERROR, "Missing required fields"

            action = callback_data.get('action')
            action_type = callback_data.get('type')
            message_id = callback_data.get('message_id')
            original_text = callback_data.get('original_text', '')
            original_response = callback_data.get('response', '')
            
            with self.element.env.getReqContext(self.element.appId):
                CorpMember = app.getElement("corps.models.CorpMember")
                app.currentUser = CorpMember()
                agent = app.getElement("aiagents.ragTest")
                
                if action == "feedback":
                    # å¤„ç†åé¦ˆ
                    if not action_type or action_type not in ['helpful', 'unhelpful']:
                        self.logger.error(f"Invalid feedback type: {action_type}")
                        return AckMessage.STATUS_ERROR, "Invalid feedback type"

                    feedback_type = "positive" if action_type == "helpful" else "negative"
                    # TODO: å­˜å‚¨åé¦ˆæ•°æ®
                    self.logger.info(f"Received {feedback_type} feedback for message {message_id}")
                    
                    # æ›´æ–°å¡ç‰‡
                    card_data = {
                        "config": {
                            "autoLayout": True,
                            "enableForward": True
                        },
                        "header": {
                            "title": {
                                "type": "text",
                                "text": "JitAI æ™ºèƒ½åŠ©æ‰‹"
                            },
                            "logo": "@lALPDfJ6V_FPDmvNAfTNAfQ"
                        },
                        "contents": [
                            {
                                "type": "markdown",
                                "text": original_response,
                                "id": f"text_{int(time.time() * 1000)}"
                            },
                            {
                                "type": "divider",
                                "id": f"divider_{int(time.time() * 1000)}"
                            },
                            {
                                "type": "action",
                                "actions": [
                                    {
                                        "type": "button",
                                        "label": {
                                            "type": "text",
                                            "text": "ğŸ”„ é‡æ–°ç”Ÿæˆ",
                                            "id": f"text_regenerate_{int(time.time() * 1000)}"
                                        },
                                        "actionType": "request",
                                        "status": "normal",
                                        "id": f"button_regenerate_{int(time.time() * 1000)}",
                                        "value": json.dumps({
                                            "action": "regenerate",
                                            "message_id": message_id,
                                            "original_text": original_text
                                        })
                                    },
                                    {
                                        "type": "button",
                                        "label": {
                                            "type": "text",
                                            "text": "[ç–‘é—®] ç»§ç»­æé—®",
                                            "id": f"text_continue_{int(time.time() * 1000)}"
                                        },
                                        "actionType": "request",
                                        "status": "normal",
                                        "id": f"button_continue_{int(time.time() * 1000)}",
                                        "value": json.dumps({
                                            "action": "continue_chat",
                                            "message_id": message_id
                                        })
                                    }
                                ],
                                "id": f"action_{int(time.time() * 1000)}"
                            },
                            {
                                "type": "text",
                                "text": "æ„Ÿè°¢æ‚¨çš„åé¦ˆï¼",
                                "id": f"text_tips_{int(time.time() * 1000)}"
                            }
                        ]
                    }
                    
                    self.reply_card(
                        card_data=card_data,
                        incoming_message=incoming_message,
                        at_sender=True
                    )
                
                elif action == "regenerate":
                    if not original_text:
                        self.logger.error("Missing original text for regeneration")
                        return AckMessage.STATUS_ERROR, "Missing original text"

                    # é‡æ–°ç”Ÿæˆå›ç­”
                    new_response = agent.run(
                        params={"input_data": original_text},
                        chatId=incoming_message.sender_staff_id,
                        stream_callback=None
                    )
                    
                    # æ›´æ–°å¡ç‰‡
                    final_card_data = self._create_final_card(new_response, incoming_message, original_text)
                    self.reply_card(
                        card_data=final_card_data,
                        incoming_message=incoming_message,
                        at_sender=True
                    )
                
                elif action == "continue_chat":
                    # ç»§ç»­å¯¹è¯
                    self.reply_text(
                        "è¯·ç»§ç»­è¾“å…¥æ‚¨çš„é—®é¢˜ï¼Œæˆ‘ä¼šç»§ç»­ä¸ºæ‚¨è§£ç­”ã€‚",
                        incoming_message
                    )
                else:
                    self.logger.error(f"Unknown action type: {action}")
                    return AckMessage.STATUS_ERROR, "Unknown action type"
            
            return AckMessage.STATUS_OK, 'OK'
            
        except Exception as e:
            self.logger.error(f"Error handling button callback: {str(e)}")
            return AckMessage.STATUS_ERROR, str(e)
```

  </TabItem>
  <TabItem value="client_managerpy" label="dingTalkStreamType/client_manager.py">

```python title="client_manager.py"
import threading
import dingtalk_stream
import asyncio
from typing import Optional
from jit.commons.utils.logger import log as logger

class ClientManager:
    def __init__(self, client_id: str, client_secret: str):
        """
        åˆå§‹åŒ– ClientManager
        
        Args:
            client_id: é’‰é’‰åº”ç”¨çš„ Client ID
            client_secret: é’‰é’‰åº”ç”¨çš„ Client Secret
        """
        self.client_id = client_id
        self.client_secret = client_secret
        self.client: Optional[dingtalk_stream.DingTalkStreamClient] = None
        self._thread: Optional[threading.Thread] = None
        self._stop_event = threading.Event()
        self._loop: Optional[asyncio.AbstractEventLoop] = None

    def start(self, message_handler):
        """
        å¯åŠ¨å®¢æˆ·ç«¯å¹¶åœ¨å•ç‹¬çš„çº¿ç¨‹ä¸­è¿è¡Œ
        
        Args:
            message_handler: æ¶ˆæ¯å¤„ç†å™¨å®ä¾‹
        """
        if self._thread and self._thread.is_alive():
            logger.warning("Client is already running")
            return

        # åˆ›å»ºå‡­è¯å’Œå®¢æˆ·ç«¯
        credential = dingtalk_stream.Credential(self.client_id, self.client_secret)
        self.client = dingtalk_stream.DingTalkStreamClient(credential)
        
        # æ³¨å†Œæ¶ˆæ¯å¤„ç†å™¨
        self.client.register_callback_handler(
            dingtalk_stream.chatbot.ChatbotMessage.TOPIC,
            message_handler
        )

        # åˆ›å»ºå¹¶å¯åŠ¨çº¿ç¨‹
        self._thread = threading.Thread(target=self._run_client, daemon=True)
        self._thread.start()
        logger.info("Client started in background thread")

    def _run_client(self):
        """åœ¨çº¿ç¨‹ä¸­è¿è¡Œå®¢æˆ·ç«¯"""
        try:
            # ä¸ºè¿™ä¸ªçº¿ç¨‹åˆ›å»ºæ–°çš„äº‹ä»¶å¾ªç¯
            self._loop = asyncio.new_event_loop()
            asyncio.set_event_loop(self._loop)
            
            # è¿è¡Œå®¢æˆ·ç«¯
            self._loop.run_until_complete(self.client.start_forever())
        except Exception as e:
            logger.error(f"Error in client thread: {e}")
        finally:
            try:
                # æ¸…ç†äº‹ä»¶å¾ªç¯
                if self._loop and self._loop.is_running():
                    self._loop.stop()
                if self._loop and not self._loop.is_closed():
                    self._loop.close()
            except Exception as e:
                logger.error(f"Error cleaning up event loop: {e}")
            self._stop_event.set()

    def stop(self):
        """åœæ­¢å®¢æˆ·ç«¯"""
        if not self._thread or not self._thread.is_alive():
            logger.warning("Client is not running")
            return

        try:
            if self.client:
                # åœ¨äº‹ä»¶å¾ªç¯ä¸­åœæ­¢å®¢æˆ·ç«¯
                if self._loop and self._loop.is_running():
                    self._loop.call_soon_threadsafe(self.client.stop)
                else:
                    self.client.stop()
            self._stop_event.wait(timeout=5)  # ç­‰å¾…çº¿ç¨‹ç»“æŸï¼Œæœ€å¤šç­‰å¾…5ç§’
            logger.info("Client stopped")
        except Exception as e:
            logger.error(f"Error stopping client: {e}")

    def is_running(self) -> bool:
        """æ£€æŸ¥å®¢æˆ·ç«¯æ˜¯å¦æ­£åœ¨è¿è¡Œ"""
        return self._thread is not None and self._thread.is_alive() 
```

  </TabItem>

  <TabItem value="loaderpy" label="dingTalkStreamType/loader.py">

```python title="loader.py"
import re
import json
from .handler import TextHandler
from .client_manager import ClientManager

class Loader(object):
    def __init__(self, nodes):
        self.nodes = nodes

    def renderTemplateString(self, source, **context):
        pattern = r"\{\{(\w+)\}\}"
        def replaceVar(match):
            var_name = match.group(1)
            return str(context.get(var_name, ""))
        rendered = re.sub(pattern, replaceVar, source)
        return rendered
    
    def load(self):
        element=self.nodes[0]
        file=element.getFile("config.json")
        config = self.renderTemplateString(file, **app.envVars)
        config = json.loads(config)
        clientId = config.get("clientId")
        clientSecret = config.get("clientSecret")
        return self.start_client(clientId, clientSecret)

    def start_client(self,client_id: str, client_secret: str):
        """
        å¯åŠ¨é’‰é’‰æµå¼å®¢æˆ·ç«¯
        
        Args:
            client_id: é’‰é’‰åº”ç”¨çš„ Client ID
            client_secret: é’‰é’‰åº”ç”¨çš„ Client Secret
            logger: æ—¥å¿—è®°å½•å™¨
        """
        # åˆ›å»ºæ¶ˆæ¯å¤„ç†å™¨
        message_handler = TextHandler(self.nodes[0])
        
        # åˆ›å»ºå¹¶å¯åŠ¨å®¢æˆ·ç«¯ç®¡ç†å™¨
        client_manager = ClientManager(client_id, client_secret)
        client_manager.start(message_handler)
        
        return client_manager
```

  </TabItem>
  <TabItem value="initpy" label="dingTalkStreamType/__init__.py">

```python title="__init__.py"
from .loader import Loader

__all__ = ["Loader"]
```

  </TabItem>
</Tabs>

### imRobots.dingTalkDemo å®ä¾‹å…ƒç´ 

<Tabs>
  <TabItem value="ejson" label="dingTalkDemo/e.json">

```json title="e.json"
{
  "backendBundleEntry": ".",
  "backendLoadTime": "afterAppInit",
  "type": "imRobots.dingTalkStreamType",
  "title": "é’‰é’‰æ™ºèƒ½å®¢æœ",
  "description": "JitAiæ™ºèƒ½å®¢æœé’‰é’‰æœºå™¨äººå®ä¾‹ï¼Œé…ç½®å…·ä½“å‚æ•°"
}
```

  </TabItem>
  <TabItem value="configjson" label="dingTalkDemo/config.json">

```json title="config.json"
{
    "clientId": "<clientId>",
    "clientSecret": "<clientSecret>"
}
```

:::tip
`clientId`å’Œ`clientSecret`éœ€è¦ä»é’‰é’‰å¼€å‘è€…å¹³å°è·å–ï¼Œåœ¨è¿™é‡Œå¡«å†™å®é™…å€¼ã€‚

æœ‰å“ªäº›é…ç½®æ˜¯Typeå…ƒç´ çš„loader.pyå†³å®šçš„ã€‚
:::

  </TabItem>
</Tabs>

---

## è§¦å‘å…ƒç´ æ‰“åŒ…
åˆ é™¤distç›®å½•ï¼Œé‡å¯JitNodeï¼Œåˆ°é’‰é’‰ç¾¤ä¸­å‘é€æ¶ˆæ¯å¹¶@æœºå™¨äººï¼ŒæŸ¥çœ‹æ•ˆæœã€‚






