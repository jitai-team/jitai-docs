{
  "entities": [
    {
      "name": "JitAi技术体系",
      "type": "Memory",
      "observations": [
        "JitAi = Jit + AI，Just In Time即时、快速构建，for AI application",
        "为AI而生的下一代应用开发技术体系",
        "旨在加快企业级AI应用落地，开启AI应用规模化时代",
        "通过解释型系统、矩阵型元架构、图形化编排开发、自动化运维的有机结合建立完整技术体系",
        "核心技术组件包括：应用运行平台、开发工具、运维工具和开发框架",
        "以矩阵型元架构为核心，实现高度模块化和可复用的全栈开发框架",
        "集成AI能力组件（AI大模型、AI知识库、AIAgent、AI助理）和企业级业务组件",
        "通过JAAP协议实现技术体系的模块化和标准化",
        "构建了从开发工具到运维平台的完整技术链路"
      ]
    },
    {
      "name": "学习路径",
      "type": "Memory",
      "observations": [
        "从初学者到专家的渐进式能力提升路径",
        "包含应用案例、元素开发最佳实践、本地开发调试、性能优化指南",
        "由简单到复杂的递进式学习结构",
        "帮助开发者系统性掌握JitAi技术体系"
      ]
    },
    {
      "name": "分布式发布部署",
      "type": "Memory",
      "observations": [
        "支持平台部署、平台更新、应用部署、应用更新的完整生命周期管理",
        "服务器端实现像浏览器端一样的自动按需加载最新应用机制",
        "开发者无需为私有化环境的部署更新而烦恼，实现零配置部署",
        "支持一键分布式部署，简化复杂环境下的应用分发",
        "分布式部署架构支持多节点协同和负载均衡",
        "实现应用的热更新和版本管理，确保业务连续性",
        "自动化的依赖管理和环境配置，降低运维复杂度"
      ]
    },
    {
      "name": "模块自描述机制",
      "type": "Memory",
      "observations": [
        "模块具备自描述能力：功能描述、数据处理能力、任务执行范围、参数规范、调用示例",
        "使AI能够理解和调用模块功能",
        "支持动态发现和智能选择模块",
        "为企业级AI应用提供模块管理基础"
      ]
    },
    {
      "name": "封装开放设计策略",
      "type": "Memory",
      "observations": [
        "JitAi封装开放原则在架构层面的具体体现和分层设计",
        "底层基础设施封装策略：封装系统级基础能力，开放应用容器接口",
        "应用架构模型封装策略：封装JAAP协议、元素机制等架构级能力",
        "技术实现模块封装策略：基于元素机制的技术模块层与业务定义层分离",
        "实现封装与开放的辩证统一：高度封装提升复用性，完全开放保持扩展性",
        "形成多层次、多维度的架构设计模式，指导具体技术实现",
        "JitAi实现封装开放设计哲学的具体技术策略和实施方案",
        "平台封装策略：封装设备基础设施和物理集群环境的虚拟化、前后端网络通信协同、应用管理、元素管理、安全验证、进程管理、线程管理等基础能力",
        "平台开放策略：开放应用容器和元素容器能力，不负责任何技术和业务能力，给到应用系统完整的自由度和扩展性",
        "开发框架封装策略：封装复用、通用、标准的技术实现，提供高集成度、高复用度的应用平台和应用开发框架",
        "开发框架开放策略：开放扩展、差异、定制能力，在更高的封装度的情况下，仍然拥有完全的开放性",
        "通过多层次、多维度的技术策略实现封装与开放的有机结合"
      ]
    },
    {
      "name": "架构设计原理",
      "type": "Memory",
      "observations": [
        "架构设计是对复杂性的管理艺术",
        "基于三个基本原理：分治、抽象、组合",
        "分治原理：将复杂问题分解为独立的子问题",
        "抽象原理：隐藏细节，突出关键特征",
        "组合原理：通过复用对接基础抽象单元构建复杂功能"
      ]
    },
    {
      "name": "AI应用开发范式",
      "type": "Memory",
      "observations": [
        "AI应用开发范式的本质：AI+人协同完成目标",
        "从人机交互到人智协同的变革",
        "从硬编码驱动到AI决策驱动的转变",
        "AI驱动的全栈工具调用流程",
        "开发者不再仅仅是开发一套操作界面和预设的固定逻辑"
      ]
    },
    {
      "name": "企业级AI应用特征",
      "type": "Memory",
      "observations": [
        "深度业务集成和精细化管控",
        "涵盖管理与助理两大应用形态的企业级特征体系",
        "涵盖技术架构、应用要求、协同机制、复杂度层次的完整特征"
      ]
    },
    {
      "name": "JAAP协议",
      "type": "Memory",
      "observations": [
        "Jit Ai Application Protocol，解释型应用架构协议",
        "由应用规范和元素规范两部分组成",
        "定义了应用系统的构建标准和模块化架构",
        "从结构定义和过程驱动层面实现应用开发的复杂性抽象",
        "应用运行平台对其进行解释执行，实现跨平台运行",
        "让应用系统成为可被AI动态感知、动态调用、动态编排的解释型系统",
        "把传统应用生态带入AI驱动和AI编排时代",
        "JitAi技术体系的核心协议和运行机制",
        "包含JAAP统一架构语言、矩阵型元架构、运行时机制",
        "定义了应用开发和运行的标准规范",
        "实现了系统的可扩展性和互操作性"
      ]
    },
    {
      "name": "应用规范",
      "type": "Memory",
      "observations": [
        "定义应用的基本信息和运行参数",
        "标准化的应用目录结构",
        "应用部署路径规则：运行环境目录/组织ID/应用ID/应用版本",
        "应用配置清单app.json",
        "应用继承机制：子应用可继承父应用的元素和配置"
      ]
    },
    {
      "name": "元素规范",
      "type": "Memory",
      "observations": [
        "采用三层元素架构设计，实现高度的可扩展性和复用性",
        "每个元素遵循统一的目录结构和文件命名规范",
        "元素定义清单e.json、运行时配置 config.json、元素加载器loader.py、生命周期管理lifecycle.py",
        "元素支持完整的生命周期管理机制",
        "支持HTTP协议直接调用元素实例",
        "实现高度可扩展性和复用性的分层架构设计",
        "Meta元素：type字段为空，直接由平台内核加载，作为元素族类的根节点",
        "Type元素：type字段指向Meta元素或其他Type元素，封装技术领域的完整基础设施",
        "Instance元素：type字段必须指向Type元素，仅包含业务相关配置和轻量逻辑",
        "元素加载流程：平台内核→Meta元素→Type元素→Instance元素"
      ]
    },
    {
      "name": "矩阵型元架构",
      "type": "Memory",
      "observations": [
        "开创性的通用统一的架构模式",
        "横向元素族类与纵向元素分层的矩阵组织方式",
        "由元素族类、元素分层、应用继承机制共同构成",
        "实现通用统一、高度复用、自由扩展的特性",
        "提供无与伦比的复用和扩展能力",
        "极致简化开发框架、工具、生态的复用和扩展",
        "基于编排编程架构机制，实现面向AI&GUI的基础架构技术",
        "通过元素三层架构和关注点分离，提供超越传统框架的架构能力"
      ]
    },
    {
      "name": "前端元素对象",
      "type": "Memory",
      "observations": [
        "ElementDefine对象，描述元素的定义信息",
        "内容与元素e.json内容一致",
        "通过App对象的相关方法获取元素定义",
        "支持按类型、目录、实例等方式获取元素定义"
      ]
    },
    {
      "name": "运行时机制",
      "type": "Memory",
      "observations": [
        "通过微内核架构和解释型执行模式，实现应用的动态加载、热更新和智能路由",
        "请求处理流程：运行环境路由、应用路由、元素路由",
        "应用实例化流程：应用资源自动热部署、应用目录校验、构建状态判断、应用实例化",
        "元素查找流程：运行时容器查询、应用配置查询、继承链追溯",
        "性能优化机制：懒加载策略、多层缓存机制"
      ]
    },
    {
      "name": "JitAi开发框架",
      "type": "Memory",
      "observations": [
        "基于矩阵型元架构的高度可复用、可扩展模块化开发框架",
        "提供Ai、Auth、I18N、Message、ORM、Pay、Service、Storage、Task、Web、Workflow等11个全栈业务开发组件",
        "所有组件均遵循JAAP规范，在开发工具中开箱即用",
        "将普适、通用的套路和组件模式封装为不同的元素族类",
        "支持开发者扩展定义自己的元素族类，也可通过继承改写官方元素族类",
        "实现高集成度且高开放度的编排式编程框架",
        "让业务层高度可编排，复杂度和工程量降低90%"
      ]
    },
    {
      "name": "JitAi应用运行平台",
      "type": "Memory",
      "observations": [
        "微内核的JAAP应用解释与运行平台",
        "JAAP应用运行容器：类比JVM和Docker，解释JAAP配置，跨平台运行JitAi应用",
        "支持跨平台运行：Windows、MacOS、Linux操作系统",
        "提供系统级API，开发者可搭配System API和开发框架开发应用",
        "支持前后端全栈元素的开发、调试、自动构建、部署、运行、更新",
        "实现环境虚拟化：仅受硬件资源限制的运行环境虚拟化",
        "提供全面的应用生命周期管理：开发、调试、构建、部署、运行、更新",
        "内置在安装包中，随JitNode节点的启动而加载",
        "微内核架构设计：除了封装最核心的内核能力，很多系统能力都通过jitAi-app来实现",
        "系统能力包括：节点环境管理UI、集群环境管理UI、应用管理UI、应用发布和部署、应用内元素管理UI等系统业务能力",
        "平台与应用分离：平台只实现应用容器和元素容器能力，不负责任何技术和业务能力，实现完全开放"
      ]
    },
    {
      "name": "JitAi",
      "type": "Memory",
      "observations": [
        "JitAi开发框架中的AI能力组件集合",
        "包含AI大模型、AI知识库、AIAgent、AI助理四个核心AI组件",
        "遵循JAAP规范设计，支持统一的AI组件调用标准",
        "为JitAi应用提供完整的AI能力支撑",
        "提供企业级AI应用开发的基础设施",
        "作为开发框架的子模块，专门负责AI功能的封装和实现"
      ]
    },
    {
      "name": "AI大模型",
      "type": "Memory",
      "observations": [
        "企业级大模型服务网关，对接各个大模型服务厂商",
        "提供统一的模型调用接口",
        "屏蔽不同大模型厂商的API差异",
        "提供统一的调用标准和错误处理机制",
        "支持业务层按需选择模型与参数",
        "支持负载均衡与故障转移"
      ]
    },
    {
      "name": "AI知识库",
      "type": "Memory",
      "observations": [
        "基于RAG技术的企业知识管理系统",
        "支持多种数据源的智能检索和知识增强",
        "支持文档、数据库、API等多种知识源",
        "实时更新：知识库内容动态同步，保证信息时效性",
        "基于向量数据库的智能语义匹配和检索",
        "应用场景：企业内部文档和制度的智能问答、产品手册和技术文档的自动检索、客户服务知识库的智能匹配、行业知识和最佳实践的智能推荐"
      ]
    },
    {
      "name": "AIAgent",
      "type": "Memory",
      "observations": [
        "AI应用的核心执行引擎",
        "负责工具编排、全链路状态跟踪和任务执行",
        "支持动态组合和调用各种业务工具和服务",
        "维护对话上下文、任务执行状态和数据流转状态",
        "复杂业务逻辑的分解和执行",
        "基于用户角色的工具访问权限管理"
      ]
    },
    {
      "name": "AI助理",
      "type": "Memory",
      "observations": [
        "AI应用与用户交互的统一界面",
        "支持可视化编排：通过可视化界面实现路由决策、AI Agent编排、人机交互设计",
        "实现多Agent协同：助理中可编排多个Agent，实现Multi Agent协作",
        "提供智能路由：根据用户意图自动选择合适的Agent处理任务",
        "支持复杂业务逻辑：函数调用、条件分支、多任务执行",
        "一键集成：以不同形态的入口集成到业务系统的各个角落"
      ]
    },
    {
      "name": "JitAuth",
      "type": "Memory",
      "observations": [
        "身份认证和权限管理组件",
        "基于RBAC（Role-Based Access Control）的权限控制体系",
        "支持多元化身份认证机制配置",
        "提供角色、组织架构、登录方式等权限管理元素"
      ]
    },
    {
      "name": "JitORM",
      "type": "Memory",
      "observations": [
        "对象关系映射框架",
        "以数据库元素、数据类型元素、模型元素为核心组成",
        "包含5大核心模块：数据库支持、数据类型系统、数据模型系统、Q表达式、TQL查询语言",
        "支持SQLite、MySQL、PostgreSQL、Oracle、SQL Server、达梦等多种数据库",
        "提供普通数据模型、聚合表模型、扩展表模型、数据对象模型四种模型",
        "自动管理数据库连接，内置业务层常用的数据操作接口",
        "提供Q表达式、TQL等辅助数据查询工具",
        "实现元素机制与传统框架的根本区别：自定义加载构造 vs 固定加载程序",
        "将替代Spring等传统框架，实现真正的面向AI&GUI的架构能力"
      ]
    },
    {
      "name": "JitWeb",
      "type": "Memory",
      "observations": [
        "Web应用开发组件",
        "提供页面、组件、门户等UI构建单元",
        "支持组件化布局或代码开发实现特定业务功能",
        "门户：系统访问入口，应用默认提供使用区、开发区、管理区三类门户",
        "页面：功能模块界面，通过组件化布局或代码开发实现特定业务功能",
        "组件：可复用的UI构建单元，提供标准化的界面交互能力"
      ]
    },
    {
      "name": "JitService",
      "type": "Memory",
      "observations": [
        "业务逻辑处理组件",
        "封装核心业务规则和流程",
        "提供业务服务接口",
        "业务逻辑层的核心组件，实现业务规则的封装和复用"
      ]
    },
    {
      "name": "JitWorkflow",
      "type": "Memory",
      "observations": [
        "工作流程管理组件",
        "支持业务流程管理",
        "定义审批节点和流转规则",
        "业务流程管理，支持复杂的企业级审批流程"
      ]
    },
    {
      "name": "JitTask",
      "type": "Memory",
      "observations": [
        "任务调度组件",
        "支持定时任务和批处理任务的执行模板",
        "任务调度层的核心组件，管理定时任务和批处理任务"
      ]
    },
    {
      "name": "JitStorage",
      "type": "Memory",
      "observations": [
        "存储服务组件",
        "提供文件存储和管理能力",
        "基础设施层的存储服务，支持文件上传、下载、管理等功能"
      ]
    },
    {
      "name": "JitMessage",
      "type": "Memory",
      "observations": [
        "消息通信组件",
        "支持各种消息通信机制",
        "集成服务层的消息组件，支持邮件、短信、即时消息等通信方式"
      ]
    },
    {
      "name": "JitPay",
      "type": "Memory",
      "observations": [
        "支付组件",
        "提供支付集成能力",
        "集成服务层的支付组件，支持多种支付方式和支付渠道的集成"
      ]
    },
    {
      "name": "JitI18N",
      "type": "Memory",
      "observations": [
        "国际化组件",
        "支持多语言应用开发",
        "基础设施层的国际化支持，实现应用的多语言支持"
      ]
    },
    {
      "name": "JitCommons",
      "type": "Memory",
      "observations": [
        "通用工具组件",
        "提供常用的工具和库函数",
        "通用工具层，包含各种常用的工具类和库函数"
      ]
    },
    {
      "name": "按需加载热更新",
      "type": "Memory",
      "observations": [
        "通过微内核架构和解释型执行模式，实现应用的动态加载、热更新和智能路由",
        "请求处理流程：运行环境路由、应用路由、元素路由",
        "应用实例化流程：应用资源自动热部署、应用目录校验、构建状态判断、应用实例化",
        "元素查找流程：运行时容器查询、应用配置查询、继承链追溯",
        "性能优化机制：懒加载策略、多层缓存机制"
      ]
    },
    {
      "name": "开发框架",
      "type": "Memory",
      "observations": [
        "基于矩阵型元架构的高度可复用、可扩展模块化开发框架",
        "提供Ai、Auth、I18N、Message、ORM、Pay、Service、Storage、Task、Web、Workflow等11个全栈业务开发组件",
        "所有组件均遵循JAAP规范，在开发工具中开箱即用",
        "将普适、通用的套路和组件模式封装为不同的元素族类",
        "支持开发者扩展定义自己的元素族类，也可通过继承改写官方元素族类",
        "实现高集成度且高开放度的编排式编程框架",
        "让业务层高度可编排，复杂度和工程量降低90%"
      ]
    },
    {
      "name": "极简开发机制",
      "type": "Memory",
      "observations": [
        "JitAi的应用系统，其源代码的复杂度和代码量是传统应用的仅仅 5%",
        "基于元素机制的技术模块层+业务定义层分层模式，最大化实现系统的复用度和开放度",
        "应用级的继承式复用，零依赖无侵入的复用和扩展，彻底解决通用标品和个性化定制的冲突难题",
        "基于“系统=结构+过程”的体系化认识，通过结构化设计简化过程复杂度",
        "所有模块基于元素规范构建，具备自描述、动态加载、完全解耦特性",
        "遵循“技术模块层+业务定义层”分层模式，最大化实现系统复用度和开放度",
        "实现源代码复杂度和代码量仅为传统应用的5%，显著提升开发效率",
        "支持可视化编排和编程双模式，保持完全的开发自由度",
        "通过应用级继承式复用，彻底解决通用标品和个性化定制的冲突",
        "兼具零代码特性和完全编程能力，不对应用开发造成任何限制"
      ]
    },
    {
      "name": "系统灵动性实现",
      "type": "Memory",
      "observations": [
        "让应用系统成为可被AI动态感知的解释型系统",
        "实现AI对应用系统的动态调用能力",
        "支持AI对应用组件的动态编排",
        "解决系统复杂度与开发效率的矛盾"
      ]
    },
    {
      "name": "Q表达式",
      "type": "Memory",
      "observations": [
        "Query Expression，构建面向数据模型的查询条件语法",
        "以简洁、直观的字符串方式表达复杂的查询逻辑",
        "支持比较操作符（=、!=、>、>=、<、<=）",
        "支持包含操作符（in、nin）、模糊匹配（like、startswith、endswith）、空值判断（isnull）等"
      ]
    },
    {
      "name": "TQL查询语言",
      "type": "Memory",
      "observations": [
        "Table Query Language，构建面向数据模型的数据查询语法",
        "查询条件使用Q表达式构建",
        "支持基本查询、关联查询、排序分页、聚合查询、联合查询",
        "支持数据操作：插入（Insert）、更新（Update）、删除（Delete）"
      ]
    },
    {
      "name": "SQLite数据库",
      "type": "Memory",
      "observations": [
        "轻量级关系型数据库",
        "数据库类型标识：sqlite",
        "Type元素fullName：databases.SqliteType",
        "配置文件包含database路径设置"
      ]
    },
    {
      "name": "MySQL数据库",
      "type": "Memory",
      "observations": [
        "开源关系型数据库",
        "数据库类型标识：mysql",
        "Type元素fullName：databases.MySQLType",
        "配置文件包含host、port、user、password、database等连接信息"
      ]
    },
    {
      "name": "PostgreSQL数据库",
      "type": "Memory",
      "observations": [
        "高级开源关系型数据库",
        "Type元素fullName：databases.PgSqlType",
        "配置文件包含dbname、host、port、user、password等连接信息"
      ]
    },
    {
      "name": "Oracle数据库",
      "type": "Memory",
      "observations": [
        "企业级商业关系型数据库",
        "Type元素fullName：databases.OracleType",
        "配置文件包含service_name、host、port、user、password等连接信息"
      ]
    },
    {
      "name": "SQL Server数据库",
      "type": "Memory",
      "observations": [
        "微软企业级关系型数据库",
        "Type元素fullName：databases.SqlServerType",
        "配置文件包含database、host、port、user、password等连接信息"
      ]
    },
    {
      "name": "达梦数据库",
      "type": "Memory",
      "observations": [
        "国产自主可控关系型数据库",
        "Type元素fullName：databases.DmdbType",
        "配置文件包含schema、host、port、user、password等连接信息"
      ]
    },
    {
      "name": "基础字段类型",
      "type": "Memory",
      "observations": [
        "单行文本、多行文本、数字、金额、百分比等基础数据类型",
        "包含富文本、编号、流水号等特殊文本类型",
        "适用于大部分常规业务数据场景",
        "提供标准的输入验证和显示功能"
      ]
    },
    {
      "name": "选择器类型",
      "type": "Memory",
      "observations": [
        "选项组单选/多选、下拉选择、检查框等选择类型",
        "日期时间选择器",
        "支持多种选择交互方式",
        "适用于数据列表、状态选择等场景"
      ]
    },
    {
      "name": "附件类型",
      "type": "Memory",
      "observations": [
        "文件、图片、手写签名等附件类型",
        "支持文件上传、存储和下载功能",
        "适用于文档管理、图片展示、电子签名等场景"
      ]
    },
    {
      "name": "组织架构类型",
      "type": "Memory",
      "observations": [
        "部门单选/多选、成员单选/多选等组织架构相关类型",
        "与企业组织架构数据紧密集成",
        "适用于人员管理、权限控制、工作流等场景"
      ]
    },
    {
      "name": "特殊字段类型",
      "type": "Memory",
      "observations": [
        "地址、身份证号、车牌号、电话号码等业务特定类型",
        "定位、超链接、子表等复杂功能类型",
        "内置业务验证规则和专用显示组件",
        "适用于特定业务领域的数据处理"
      ]
    },
    {
      "name": "数据容器类型",
      "type": "Memory",
      "observations": [
        "字典、列表、映射、单行数据、多行数据等容器类型",
        "不可用于模型字段，主要用于业务逻辑处理",
        "支持复杂数据结构的存储和操作",
        "适用于数据转换、中间结果存储等场景"
      ]
    },
    {
      "name": "关联数据类型",
      "type": "Memory",
      "observations": [
        "关联数据、筛选条件等数据关联类型",
        "实现模型间的数据关联和引用",
        "支持外键关系和复杂查询条件",
        "适用于关联查询、数据联动等场景"
      ]
    },
    {
      "name": "普通数据模型",
      "type": "Memory",
      "observations": [
        "最常见的数据模型，每个实例对应指定数据库中的一张表",
        "对模型字段的变更会自动同步到数据库中",
        "开发人员无需手动维护数据库表",
        "支持所有类型的数据字段定义"
      ]
    },
    {
      "name": "聚合表模型",
      "type": "Memory",
      "observations": [
        "用于多数据模型关联的复杂数据分析场景",
        "支持分组汇总（GROUP BY）、追加合并（UNION）、横向连接（JOIN）",
        "三种模式可以嵌套组合使用",
        "适用于数据统计、报表生成等场景"
      ]
    },
    {
      "name": "扩展表模型",
      "type": "Memory",
      "observations": [
        "以一个普通数据模型作为基础模型",
        "通过字段关联规则链式地关联（LEFT JOIN）其他数据模型",
        "对被关联模型的字段进行聚合统计（SUM、COUNT、MAX等）",
        "适用于复杂业务查询和数据关联分析"
      ]
    },
    {
      "name": "数据对象模型",
      "type": "Memory",
      "observations": [
        "当前仅支持全代码方式使用",
        "可类比为DTO（Data Transfer Object）",
        "完全由开发者按需定义，不与数据库关联",
        "在业务逻辑流转中使用，适用于数据传输和中间处理"
      ]
    },
    {
      "name": "应用运行平台前端",
      "type": "Memory",
      "observations": [
        "前端平台API的核心模块",
        "提供元素内部访问和全局访问机制",
        "支持元素定义管理和应用对象操作",
        "为前端元素提供统一的平台服务接口"
      ]
    },
    {
      "name": "应用运行平台后端",
      "type": "Memory",
      "observations": [
        "后端平台API的核心模块",
        "包含应用管理、运行环境管理、元素管理和Jit节点管理",
        "提供完整的应用生命周期管理能力",
        "支持源码管理和资源管理功能"
      ]
    },
    {
      "name": "前端App对象",
      "type": "Memory",
      "observations": [
        "前端平台API的核心，提供应用级别的属性和方法",
        "可通过this.app在元素内部访问，或getRuntimeApp全局访问",
        "包含appId、name、title等应用基本属性",
        "提供元素获取和操作的相关方法"
      ]
    },
    {
      "name": "后端App对象",
      "type": "Memory",
      "observations": [
        "后端应用管理的核心对象，可直接使用app关键字调用",
        "包含appId、appKey、version、title等丰富的应用属性",
        "包含env、node、code、resource等关联对象",
        "支持初始化数据、环境变量、依赖管理等功能"
      ]
    },
    {
      "name": "AppCode源码管理器",
      "type": "Memory",
      "observations": [
        "应用源码管理器，用于管理和操作应用的源代码文件",
        "仅在应用具有本地源码时可用（即存在app.json文件）",
        "通常用于开发调试场景",
        "支持文件存在性检查、目录判断、文件读写等操作"
      ]
    },
    {
      "name": "AppResource资源管理器",
      "type": "Memory",
      "observations": [
        "应用资源管理器，用于管理和操作应用的已打包资源文件",
        "用于运行时环境，负责从内存中读取应用的打包资源",
        "包括元素资源、公共资源等",
        "支持资源存在性检查、资源读取等操作"
      ]
    },
    {
      "name": "Environ运行环境",
      "type": "Memory",
      "observations": [
        "运行环境对象，用于管理和控制应用的运行环境",
        "在同一个运行环境中，每个AppId只能运行一个版本",
        "包含envId、orgId、title、rootPath等环境属性",
        "支持应用获取、路径管理、部署规则等功能"
      ]
    },
    {
      "name": "Element元素对象",
      "type": "Memory",
      "observations": [
        "元素对象，通过app.getElement(fullName)获取",
        "包含envId、appId、version、define、fullName等元素属性",
        "支持元素文件读取和管理",
        "实现了对执行对象的透明代理，可直接调用执行对象的方法和属性"
      ]
    },
    {
      "name": "技术痛点解决方案",
      "type": "Memory",
      "observations": [
        "针对传统技术体系中应用系统无法被AI动态感知的问题，提供基于解释型系统的解决方案",
        "解决传统模块静态依赖造成的高耦合问题，实现组件的动态加载和解耦",
        "可扩展性解决方案：通过元素机制实现零依赖无侵入的复用和扩展",
        "灵活性解决方案：让应用系统成为可被AI动态调用和编排的系统",
        "轻量化解决方案：源代码复杂度和代码量仅为传统应用的5%",
        "开放性解决方案：在高封装度情况下实现完全开放",
        "适应性解决方案：自适应开发框架变更和开发者自定义元素类型"
      ]
    },
    {
      "name": "Node节点对象",
      "type": "Memory",
      "observations": [
        "Node对象对应着当前运行的Jit节点",
        "包含nodeId、startId、nodeType、port、bindIp等节点属性",
        "支持节点配置管理和版本信息",
        "所有属性均为只读属性"
      ]
    },
    {
      "name": "元素开发最佳实践",
      "type": "Memory",
      "observations": [
        "开发工作流：需求分析→元素设计→创建元素目录→实现元素逻辑",
        "遵循单一职责：每个元素专注于特定功能领域",
        "合理使用继承：充分利用Type元素的模板能力",
        "注重性能优化：合理配置缓存和加载时机",
        "完善错误处理：实现健壮的异常处理机制",
        "保持文档同步：及时更新元素描述和接口文档"
      ]
    },
    {
      "name": "应用案例",
      "type": "Memory",
      "observations": [
        "从简单到复杂的递进式实践体系",
        "快速上手案例：5分钟开发一个AI应用（智能客服）",
        "进阶案例：集成智能客服到钉钉机器人",
        "复杂案例：AI驱动的UI自动化交互",
        "企业级案例：开发一个CRM应用"
      ]
    },
    {
      "name": "本地开发与调试",
      "type": "Memory",
      "observations": [
        "支持多种主流IDE进行本地开发调试",
        "Visual Studio Code：轻量级编辑器，丰富的Python扩展生态",
        "PyCharm：专业Python IDE，强大的调试和重构功能",
        "配置调试环境：创建调试配置文件，配置系统解释器",
        "启动调试：使用JitNode内置的Python环境进行调试"
      ]
    },
    {
      "name": "性能优化指南",
      "type": "Memory",
      "observations": [
        "多层次的性能优化策略",
        "懒加载策略：应用级、元素级、资源级的多层次懒加载",
        "多层缓存机制：进程级缓存、请求线程级缓存、持久化缓存",
        "合理配置加载时机：前端加载时机和后端加载时机的优化配置",
        "缓存级别配置：进程级别和线程级别的合理选择",
        "访问权限控制：private、protected、public修饰符的合理使用"
      ]
    },
    {
      "name": "设计理念",
      "type": "Memory",
      "observations": [
        "JitAi技术体系的设计理念和指导思想",
        "包含通用的架构设计原理和JitAi特有的价值主张",
        "为整个技术体系的设计和实现提供理论指导",
        "体现了对传统技术体系问题的深刻洞察和创新解决方案",
        "核心设计哲学：封装和开放的辩证统一，在高封装度情况下保持完全开放"
      ]
    },
    {
      "name": "JitAi价值主张",
      "type": "Memory",
      "observations": [
        "JitAi技术体系的核心价值和存在意义",
        "灵动特性：灵活、动态，让应用系统成为可被AI动态感知、调用、编排的解释型系统",
        "轻快特性：轻量、快速，解决'系统更复杂 vs 开发更高效'的相互冲突难题",
        "传统技术体系痛点：AI无法获取模块使用说明、无法动态决策和调用、静态依赖高耦合",
        "企业AI应用特点：比传统软件更纵深复杂、功能难以规划、需要边用边改、快速迭代"
      ]
    },
    {
      "name": "管理系统与助理系统",
      "type": "Memory",
      "observations": [
        "企业级AI应用两大类型：管理系统（软件）与助理系统（智件）",
        "管理系统：广泛涉及业务流程各专业环节，实现跨部门高效协同，迭代方向是互联互通一体化",
        "助理系统：深入特定专业环节，处理具体业务任务，辅助特定岗位人员，迭代目标是工具集成与系统深度融合",
        "智件比软件更复杂纵深，意味着更多差异化定制化，需要不断迭代改进",
        "JitAi可开发传统软件（ERP、CRM、OA等），也能开发与之无缝融合原生一体的AI智件",
        "基于可视化编排工具，轻易将平台模块、外部MCP服务、内部模块编排为AI智能体工具"
      ]
    },
    {
      "name": "生产级AI应用要求",
      "type": "Memory",
      "observations": [
        "企业级生产环境中安全合规、稳定可控是刚需",
        "智能体、工具、数据模型的精细化权限控制确保安全合规",
        "AI-UI灵活交互机制支持AI智能化处理与用户人工处理紧密配合",
        "满足生产级智能体稳定可控要求，确保确定性与可控性"
      ]
    },
    {
      "name": "应用运行平台",
      "type": "Memory",
      "observations": [
        "微内核的JAAP应用解释与运行平台",
        "JAAP应用运行容器：类比JVM和Docker，解释JAAP配置，跨平台运行JitAi应用",
        "支持跨平台运行：Windows、MacOS、Linux操作系统",
        "提供系统级API，开发者可搭配System API和开发框架开发应用",
        "支持前后端全栈元素的开发、调试、自动构建、部署、运行、更新",
        "实现环境虚拟化：仅受硬件资源限制的运行环境虚拟化",
        "提供全面的应用生命周期管理：开发、调试、构建、部署、运行、更新",
        "内置在安装包中，随JitNode节点的启动而加载",
        "微内核架构设计：除了封装最核心的内核能力，很多系统能力都通过jitAi-app来实现",
        "系统能力包括：节点环境管理UI、集群环境管理UI、应用管理UI、应用发布和部署、应用内元素管理UI等系统业务能力",
        "平台与应用分离：平台只实现应用容器和元素容器能力，不负责任何技术和业务能力，实现完全开放"
      ]
    },
    {
      "name": "AI应用复杂度分层",
      "type": "Memory",
      "observations": [
        "从简单AI问答到替代人类工作岗位的AI员工助理，技术方案复杂度呈分层递进",
        "函数级别：AI函数的单一功能实现",
        "代理级别：可编排agent，支持复杂任务处理",
        "助理级别：AI和UI协同的可编排assistant",
        "AI agent思维模式和工具开发集成是逐步迭代过程，每次迭代都意味着应用重构",
        "JitAi系统架构的通用性扩展性保障应用架构绝对稳定，规避推倒重来",
        "可视化编排能力支持迭代开发快速搭建，新创意需求快速落实获得反馈"
      ]
    },
    {
      "name": "Vibe Coding",
      "type": "Memory",
      "observations": [
        "体验为王的编程开发范式",
        "在最低学习成本情况下，让普通用户能够快速上手并胜任大型企业级AI应用的开发工作",
        "基于可视化编排、结构化设计和解释型执行的开发范式",
        "实现从编排式开发到可视化开发的自然过渡",
        "让开发者能够以自然的方式完成应用系统的构建和迭代",
        "通过体验化的开发方式，让应用开发从繁琐的代码编写转变为直观的体验过程",
        "支持可视化编排和编程双模式，保持完全的开发自由度"
      ]
    },
    {
      "name": "编排编程架构机制",
      "type": "Memory",
      "observations": [
        "元素meta-type-实例三层架构是面向AI&GUI的基础架构技术",
        "基于元素协议和三层结构的模块具备：自描述、自加载、零依赖、热插拔、可扩展、可替换、可编排特性",
        "元素机制解决软件模块静态依赖问题，实现模块间彻底隔离",
        "彻底实现不同类型和同类型不同层级模块间的“封闭/开放”原则",
        "横向架构各族类元素零静态依赖、最大化封闭/开放",
        "纵向架构解决通用公共部分和个性差异部分的隔离，最大化通用复用和差异自由度",
        "跨应用模块继承机制、模块类型机制、矩阵型元架构模型实现无与伦比的复用扩展",
        "实现极致关注点分离：运行平台关注底层、开发框架关注技术封装、业务系统关注差异化实现"
      ]
    },
    {
      "name": "开发模式",
      "type": "Memory",
      "observations": [
        "提供可视化编排和全代码编程双模统一的开发模式",
        "想做可视化，适合可视化编排开发模式",
        "想做编程型，适合全代码编程开发模式",
        "想做混合型，适合编排与编程相结合的混合开发模式",
        "能力范围全覆盖：从快速原型到复杂企业级应用的全覆盖",
        "支持不同能力层次的开发者，保持完全的开发自由度",
        "通过双模统一设计，让不同背景和偏好的开发者都能高效工作"
      ]
    },
    {
      "name": "复用扩展机制实现",
      "type": "Memory",
      "observations": [
        "选择合适的元素实现不同的复用策略",
        "支持继承式复用：继承父类元素进行个性化改造",
        "支持组合式复用：将多个元素组合实现复杂功能",
        "支持配置式复用：通过参数配置实现不同的行为模式",
        "支持元素内复用：在单个元素内部实现多种复用策略",
        "实现零依赖无侵入的复用和扩展，解决通用和定制的冲突",
        "通过元素机制实现应用级的继承式复用"
      ]
    },
    {
      "name": "开发工具",
      "type": "Memory",
      "observations": [
        "符合JAAP规范的双模（可视化、全代码）统一的企业级AI应用开发工具",
        "由应用运行平台解释运行，提供编排式编程体验",
        "IDEApp是JitAi打造的编程与编排双模式的企业级应用开发工具",
        "支持可视化编排和编程的开发工具和开发方式，大幅提升开发效率",
        "自适应开发框架的扩展变更以及开发者自定义的元素族类",
        "使开发速度提升10倍，让开发者从容应对AI应用的复杂多变",
        "基于极简开发机制，提供可视化编排和编程双模一体的开发体验",
        "通过结构化设计简化过程复杂度，实现高效的应用系统开发"
      ]
    },
    {
      "name": "生态库和生态应用",
      "type": "Memory",
      "observations": [
        "基于JitAi应用协议的创新生态发布模式，突破传统软件工具发布方式的局限",
        "传统方式问题：工具变更依赖发布者发布新版本，使用者因工具部分不适用而无所适从",
        "JitAi解决方案：生态开发者通过发布JitAi应用的方式提供可复用工具",
        "核心优势：第三方可无侵入修改某一部分特性、轻量级、跨平台运行",
        "灵活发布：可开源可闭源、可免费可收费的多样化发布模式",
        "应用场景：开发工具、业务组件、行业解决方案等各类可复用模块",
        "生态价值：形成丰富的第三方应用生态，降低开发成本，提高开发效率"
      ]
    },
    {
      "name": "理论层",
      "type": "Memory",
      "observations": [
        "JitAi技术体系的理论基础和设计哲学层",
        "包含设计理念、价值主张、基础原理等抽象概念",
        "为整个技术体系提供思想指导和理论依据",
        "涵盖AI应用开发范式和企业级应用特征分析",
        "体现JitAi技术创新的核心思想和价值追求"
      ]
    },
    {
      "name": "架构层",
      "type": "Memory",
      "observations": [
        "JitAi技术体系的系统架构和技术机制层",
        "包含协议规范、架构模式、运行机制等技术框架",
        "定义系统的总体设计和技术实现标准",
        "为具体实现提供架构指导和技术规范",
        "确保系统的可扩展性、可维护性和技术一致性"
      ]
    },
    {
      "name": "实现层",
      "type": "Memory",
      "observations": [
        "JitAi技术体系的具体技术实现层",
        "包含平台工具、开发框架、功能组件等实现模块",
        "提供完整的技术实现和工具支撑",
        "为应用开发提供具体的技术能力和工具集",
        "实现理论和架构的具体落地和工程化"
      ]
    },
    {
      "name": "应用层",
      "type": "Memory",
      "observations": [
        "JitAi技术体系的实践指导和应用层",
        "包含开发实践、学习路径、应用案例等实用内容",
        "为开发者提供具体的使用指导和最佳实践",
        "通过案例和教程帮助开发者掌握技术体系",
        "连接技术实现与实际业务应用的桥梁"
      ]
    },
    {
      "name": "哲学基础层",
      "type": "Memory",
      "observations": [
        "理论层的最抽象哲学思想和价值观层面",
        "包含JitAi技术体系的根本设计哲学和核心价值追求",
        "为整个技术体系提供哲学指导和价值方向",
        "体现技术创新的思想内核和精神追求"
      ]
    },
    {
      "name": "方法论层",
      "type": "Memory",
      "observations": [
        "理论层的方法论和范式指导层面",
        "包含通用设计原理和AI应用开发的方法论",
        "提供可操作的设计原则和开发范式指导",
        "连接抽象哲学与具体实践的方法桥梁"
      ]
    },
    {
      "name": "特征描述层",
      "type": "Memory",
      "observations": [
        "理论层的技术体系和应用特征描述层面",
        "从理论角度描述技术体系特点和应用领域特征",
        "为架构设计和具体实现提供特征指导",
        "体现理论在技术体系中的具体表现"
      ]
    },
    {
      "name": "封装开放设计哲学",
      "type": "Memory",
      "observations": [
        "JitAi技术体系的核心设计哲学，实现封装与开放的辩证统一",
        "通过创新实现在更高封装度情况下的完全开放，突破传统'封装度高则通用度差'的技术瓶颈",
        "极大提高复用度和开发效率，是JitAi技术体系的根本优势所在",
        "封装与开放的辩证关系：既要高度封装提升复用性，又要完全开放保持扩展性",
        "创新性解决了传统技术架构中封装度与通用度的矛盾对立问题"
      ]
    },
    {
      "name": "运维工具",
      "type": "Memory",
      "observations": [
        "符合JAAP规范的一站式自动化运维管理平台",
        "由应用运行平台解释运行",
        "支持应用的全生命周期管理：创建、发布、部署、运维",
        "提供自动化的DevOps工具，让AI应用的全流程简单化、轻量化",
        "大幅降低运维成本和复杂度"
      ]
    },
    {
      "name": "模块热插拔机制",
      "type": "Memory",
      "observations": [
        "支持模块的动态需求、数据适配、任务匹配",
        "实现实时加载、无缝替换、组合编排",
        "支持运行时模块更新和替换",
        "为系统的灵活性和可扩展性提供技术支撑"
      ]
    },
    {
      "name": "全栈工具化机制",
      "type": "Memory",
      "observations": [
        "突破传统后端服务调用的局限",
        "实现前后端统一的工具调用能力",
        "支持AI对全栈模块的统一调用",
        "为企业级AI应用提供全面的工具集成能力",
        "基本单元元素天然面向AI和UI，实现双向友好协同",
        "元素可被AI感知操控，可被UI触发调用，支持动态UI化呈现和可视化编排",
        "AI无法完成100%任务时，需要人类基于UI完成剩余工作",
        "元素化模块的AI&UI友好大幅简化此类场景的应用开发",
        "面向AI支持动态感知、面向GUI支持可视化编排的系统架构是AI时代应用开发基础",
        "助理类应用复杂度超过管理类应用，必然在“构建-使用-反馈-再构建”循环中不断增强"
      ]
    }
  ],
  "relations": [
    {
      "source": "开发框架",
      "target": "JitService",
      "relationType": "包含"
    },
    {
      "source": "开发框架",
      "target": "JitWorkflow",
      "relationType": "包含"
    },
    {
      "source": "方法论层",
      "target": "Vibe Coding",
      "relationType": "包含"
    },
    {
      "source": "特征描述层",
      "target": "系统灵动性实现",
      "relationType": "包含"
    },
    {
      "source": "开发框架",
      "target": "JitORM",
      "relationType": "包含"
    },
    {
      "source": "方法论层",
      "target": "技术痛点解决方案",
      "relationType": "包含"
    },
    {
      "source": "应用运行平台前端",
      "target": "前端App对象",
      "relationType": "包含"
    },
    {
      "source": "矩阵型元架构",
      "target": "封装开放设计策略",
      "relationType": "包含"
    },
    {
      "source": "JitORM",
      "target": "PostgreSQL数据库",
      "relationType": "包含"
    },
    {
      "source": "JAAP协议",
      "target": "元素规范",
      "relationType": "包含"
    },
    {
      "source": "JAAP协议",
      "target": "应用规范",
      "relationType": "包含"
    },
    {
      "source": "JitORM",
      "target": "MySQL数据库",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "应用运行平台",
      "relationType": "包含"
    },
    {
      "source": "开发框架",
      "target": "JitAi",
      "relationType": "包含"
    },
    {
      "source": "运维工具",
      "target": "分布式发布部署",
      "relationType": "包含"
    },
    {
      "source": "方法论层",
      "target": "开发模式",
      "relationType": "包含"
    },
    {
      "source": "前端App对象",
      "target": "前端元素对象",
      "relationType": "包含"
    },
    {
      "source": "特征描述层",
      "target": "JitAi技术体系",
      "relationType": "包含"
    },
    {
      "source": "Environ运行环境",
      "target": "AppResource资源管理器",
      "relationType": "包含"
    },
    {
      "source": "运行时机制",
      "target": "按需加载热更新",
      "relationType": "包含"
    },
    {
      "source": "JitORM",
      "target": "SQL Server数据库",
      "relationType": "包含"
    },
    {
      "source": "JitORM",
      "target": "选择器类型",
      "relationType": "包含"
    },
    {
      "source": "JitORM",
      "target": "基础字段类型",
      "relationType": "包含"
    },
    {
      "source": "JitORM",
      "target": "附件类型",
      "relationType": "包含"
    },
    {
      "source": "JitORM",
      "target": "组织架构类型",
      "relationType": "包含"
    },
    {
      "source": "JitORM",
      "target": "特殊字段类型",
      "relationType": "包含"
    },
    {
      "source": "JitORM",
      "target": "数据容器类型",
      "relationType": "包含"
    },
    {
      "source": "JitORM",
      "target": "关联数据类型",
      "relationType": "包含"
    },
    {
      "source": "JitORM",
      "target": "普通数据模型",
      "relationType": "包含"
    },
    {
      "source": "JitORM",
      "target": "聚合表模型",
      "relationType": "包含"
    },
    {
      "source": "JitORM",
      "target": "扩展表模型",
      "relationType": "包含"
    },
    {
      "source": "JitORM",
      "target": "数据对象模型",
      "relationType": "包含"
    },
    {
      "source": "JitORM",
      "target": "Q表达式",
      "relationType": "包含"
    },
    {
      "source": "JitAi",
      "target": "AIAgent",
      "relationType": "包含"
    },
    {
      "source": "Environ运行环境",
      "target": "后端App对象",
      "relationType": "包含"
    },
    {
      "source": "开发框架",
      "target": "JitMessage",
      "relationType": "包含"
    },
    {
      "source": "开发框架",
      "target": "JitPay",
      "relationType": "包含"
    },
    {
      "source": "开发框架",
      "target": "JitI18N",
      "relationType": "包含"
    },
    {
      "source": "开发框架",
      "target": "JitStorage",
      "relationType": "包含"
    },
    {
      "source": "JitORM",
      "target": "SQLite数据库",
      "relationType": "包含"
    },
    {
      "source": "方法论层",
      "target": "AI应用开发范式",
      "relationType": "包含"
    },
    {
      "source": "后端App对象",
      "target": "Element元素对象",
      "relationType": "包含"
    },
    {
      "source": "特征描述层",
      "target": "极简开发机制",
      "relationType": "包含"
    },
    {
      "source": "架构层",
      "target": "复用扩展机制实现",
      "relationType": "包含"
    },
    {
      "source": "JitORM",
      "target": "TQL查询语言",
      "relationType": "包含"
    },
    {
      "source": "JitAi",
      "target": "AI助理",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "开发工具",
      "relationType": "包含"
    },
    {
      "source": "特征描述层",
      "target": "企业级AI应用特征",
      "relationType": "包含"
    },
    {
      "source": "JitORM",
      "target": "Oracle数据库",
      "relationType": "包含"
    },
    {
      "source": "Environ运行环境",
      "target": "AppCode源码管理器",
      "relationType": "包含"
    },
    {
      "source": "开发框架",
      "target": "JitAuth",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "开发框架",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "运维工具",
      "relationType": "包含"
    },
    {
      "source": "架构层",
      "target": "全栈工具化机制",
      "relationType": "包含"
    },
    {
      "source": "应用运行平台后端",
      "target": "Environ运行环境",
      "relationType": "包含"
    },
    {
      "source": "开发框架",
      "target": "JitTask",
      "relationType": "包含"
    },
    {
      "source": "JitORM",
      "target": "达梦数据库",
      "relationType": "包含"
    },
    {
      "source": "开发框架",
      "target": "JitCommons",
      "relationType": "包含"
    },
    {
      "source": "架构层",
      "target": "模块热插拔机制",
      "relationType": "包含"
    },
    {
      "source": "应用运行平台",
      "target": "Node节点对象",
      "relationType": "包含"
    },
    {
      "source": "应用运行平台",
      "target": "应用运行平台前端",
      "relationType": "包含"
    },
    {
      "source": "开发框架",
      "target": "JitWeb",
      "relationType": "包含"
    },
    {
      "source": "应用运行平台",
      "target": "应用运行平台后端",
      "relationType": "包含"
    },
    {
      "source": "应用运行平台",
      "target": "运行时机制",
      "relationType": "包含"
    },
    {
      "source": "JitAi",
      "target": "AI知识库",
      "relationType": "包含"
    },
    {
      "source": "JitAi",
      "target": "AI大模型",
      "relationType": "包含"
    },
    {
      "source": "理论层",
      "target": "架构层",
      "relationType": "指导"
    },
    {
      "source": "架构层",
      "target": "实现层",
      "relationType": "指导"
    },
    {
      "source": "实现层",
      "target": "应用层",
      "relationType": "支撑"
    },
    {
      "source": "哲学基础层",
      "target": "设计理念",
      "relationType": "包含"
    },
    {
      "source": "方法论层",
      "target": "架构设计原理",
      "relationType": "包含"
    },
    {
      "source": "架构层",
      "target": "JAAP协议",
      "relationType": "包含"
    },
    {
      "source": "架构层",
      "target": "矩阵型元架构",
      "relationType": "包含"
    },
    {
      "source": "架构层",
      "target": "编排编程架构机制",
      "relationType": "包含"
    },
    {
      "source": "应用层",
      "target": "学习路径",
      "relationType": "包含"
    },
    {
      "source": "应用层",
      "target": "应用案例",
      "relationType": "包含"
    },
    {
      "source": "应用层",
      "target": "元素开发最佳实践",
      "relationType": "包含"
    },
    {
      "source": "应用层",
      "target": "本地开发与调试",
      "relationType": "包含"
    },
    {
      "source": "应用层",
      "target": "性能优化指南",
      "relationType": "包含"
    },
    {
      "source": "应用层",
      "target": "管理系统与助理系统",
      "relationType": "包含"
    },
    {
      "source": "应用层",
      "target": "生产级AI应用要求",
      "relationType": "包含"
    },
    {
      "source": "应用层",
      "target": "AI应用复杂度分层",
      "relationType": "包含"
    },
    {
      "source": "理论层",
      "target": "哲学基础层",
      "relationType": "包含"
    },
    {
      "source": "理论层",
      "target": "方法论层",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "JitTask",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "JitStorage",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "JitMessage",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "JitPay",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "JitI18N",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "JitCommons",
      "relationType": "包含"
    },
    {
      "source": "理论层",
      "target": "特征描述层",
      "relationType": "包含"
    },
    {
      "source": "哲学基础层",
      "target": "封装开放设计哲学",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "Node节点对象",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "普通数据模型",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "聚合表模型",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "扩展表模型",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "基础字段类型",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "PostgreSQL数据库",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "Oracle数据库",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "SQL Server数据库",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "达梦数据库",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "SQLite数据库",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "MySQL数据库",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "Q表达式",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "TQL查询语言",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "AIAgent",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "AI知识库",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "AI助理",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "AI大模型",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "选择器类型",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "特殊字段类型",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "数据容器类型",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "关联数据类型",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "组织架构类型",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "附件类型",
      "relationType": "包含"
    },
    {
      "source": "实现层",
      "target": "数据对象模型",
      "relationType": "包含"
    },
    {
      "source": "哲学基础层",
      "target": "JitAi价值主张",
      "relationType": "包含"
    },
    {
      "source": "架构层",
      "target": "模块自描述机制",
      "relationType": "包含"
    }
  ]
}